{"version":3,"sources":["AutoMapperBase.ts"],"names":["AutoMapperJs","AutoMapperJs.AutoMapperBase","AutoMapperJs.AutoMapperBase.constructor","AutoMapperJs.AutoMapperBase.getMapping","AutoMapperJs.AutoMapperBase.getKey","AutoMapperJs.AutoMapperBase.isArray","AutoMapperJs.AutoMapperBase.handleArray","AutoMapperJs.AutoMapperBase.handleItem","AutoMapperJs.AutoMapperBase.handleProperty","AutoMapperJs.AutoMapperBase.setPropertyValue","AutoMapperJs.AutoMapperBase.createDestinationObject","AutoMapperJs.AutoMapperBase.getDestinationPropertyName"],"mappings":"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","file":"AutoMapperBase.js","sourcesContent":["/// <reference path=\"../../dist/arcady-automapper-interfaces.d.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    type ICMChainFunc = IAutoMapperCreateMapChainingFunctions;\r\n\r\n    /**\r\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\r\n     * .NET AutoMapper library is the pursuit of this implementation.\r\n     */\r\n    export class AutoMapperBase {\r\n        protected getMapping(mappings: { [key: string]: IMapping }, sourceKey: string | (new () => any), destinationKey: string | (new () => any)): IMapping {\r\n            let srcKey = this.getKey(sourceKey);\r\n            let dstKey = this.getKey(destinationKey);\r\n            let mapping: IMapping = mappings[srcKey + dstKey];\r\n\r\n            if (!mapping) {\r\n                throw new Error(`Could not find map object with a source of ${srcKey} and a destination of ${dstKey}`);\r\n            }\r\n            return mapping;\r\n        }\r\n\r\n        protected getKey(keyStringOrType: string | (new () => any)): string {\r\n            if (typeof keyStringOrType === 'string') {\r\n                return keyStringOrType;\r\n            } else {\r\n                return AutoMapperHelper.getClassName(keyStringOrType);\r\n            }\r\n        }\r\n\r\n        protected isArray(sourceObject: any): boolean {\r\n            return sourceObject instanceof Array;\r\n        }\r\n\r\n        protected handleArray(mapping: IMapping, sourceArray: Array<any>, itemFunc: (sourceObject: any, destinationObject: any) => void): Array<any> {\r\n            var arrayLength = sourceArray.length;\r\n            var destinationArray = new Array<any>(sourceArray.length);\r\n\r\n            for (let index = 0; index < arrayLength; index++) {\r\n                let sourceObject = sourceArray[index];\r\n                let destinationObject: any;\r\n\r\n                if (sourceObject === null || sourceObject === undefined) {\r\n                    destinationObject = sourceObject;\r\n                } else {\r\n                    destinationObject = this.createDestinationObject(mapping.destinationTypeClass);\r\n                    itemFunc(sourceObject, destinationObject);\r\n                }\r\n\r\n                destinationArray[index] = destinationObject;\r\n            }\r\n\r\n            return destinationArray;\r\n        }\r\n\r\n        protected handleItem(mapping: IMapping, sourceObject: any, destinationObject: any, propertyFunction: (propertyName: string) => void): any {\r\n            for (let sourcePropertyName in sourceObject) {\r\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                propertyFunction(sourcePropertyName);\r\n            }\r\n\r\n            return destinationObject;\r\n        }\r\n\r\n        protected handleProperty(mapping: IMapping,\r\n                                 sourceObject: any,\r\n                                 sourcePropertyName: string,\r\n                                 destinationObject: any,\r\n                                 loopMemberValuesAndFunctions: (destinationProperty: string, valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions) => void): void {\r\n            var propertyMapping = mapping.forMemberMappings[sourcePropertyName];\r\n            if (propertyMapping) {\r\n                // a forMember mapping exists\r\n\r\n                var {\r\n                    ignore,\r\n                    conditionFunction,\r\n                    destinationProperty,\r\n                    mappingValuesAndFunctions\r\n                } = propertyMapping;\r\n\r\n                // ignore ignored properties\r\n                if (ignore) {\r\n                    return;\r\n                }\r\n\r\n                // check for condition function\r\n                if (conditionFunction) {\r\n                    // and, if there, return when the condition is not met.\r\n                    if (conditionFunction(sourceObject) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                var memberConfigurationOptions: IMemberConfigurationOptions = {\r\n                    mapFrom: (): void => {//sourceMemberKey: string) {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    condition: (predicate: ((sourceObject: any) => boolean)): void => {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    sourceObject: sourceObject,\r\n                    sourcePropertyName: sourcePropertyName,\r\n                    intermediatePropertyValue: sourceObject[sourcePropertyName]\r\n                };\r\n\r\n                loopMemberValuesAndFunctions(propertyMapping.destinationProperty, mappingValuesAndFunctions, memberConfigurationOptions);\r\n            } else {\r\n                // no forMember mapping exists, auto map properties ...\r\n\r\n                // ... except for the situation where ignoreAllNonExisting is specified.\r\n                if (mapping.ignoreAllNonExisting) {\r\n                    return;\r\n                }\r\n\r\n                // use profile mapping when specified; otherwise, specify source property name as destination property name.\r\n                let destinationPropertyName = this.getDestinationPropertyName(mapping.profile, sourcePropertyName);\r\n                this.setPropertyValue(mapping, destinationObject, destinationPropertyName, sourceObject[sourcePropertyName]);\r\n            }\r\n        }\r\n\r\n        protected setPropertyValue(mapping: IMapping, destinationObject: any, destinationProperty: string, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    forAllMemberMapping(destinationObject, destinationProperty, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationProperty] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        protected createDestinationObject(destinationType: new () => any): any {\r\n            // create empty destination object.\r\n            return destinationType\r\n                ? new destinationType()\r\n                : {};\r\n        }\r\n\r\n        private getDestinationPropertyName(profile: IProfile, sourcePropertyName: string): string {\r\n            if (!profile) {\r\n                return sourcePropertyName;\r\n            }\r\n\r\n            // TODO BL no support yet for INamingConvention.splittingCharacter\r\n\r\n            try {\r\n                // First, split the source property name based on the splitting expression.\r\n                // TODO BL Caching of RegExp splitting!\r\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\r\n\r\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\r\n                for (let index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\r\n                    if (sourcePropertyNameParts[index] === '') {\r\n                        sourcePropertyNameParts.splice(index, 1);\r\n                    }\r\n                }\r\n\r\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\r\n            } catch (error) {\r\n                return sourcePropertyName;\r\n            }\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}