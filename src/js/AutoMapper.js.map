{"version":3,"sources":["AutoMapper.ts"],"names":["AutoMapperJs","AutoMapperJs.AutoMapper","AutoMapperJs.AutoMapper.constructor","AutoMapperJs.AutoMapper.getInstance","AutoMapperJs.AutoMapper.initialize","AutoMapperJs.AutoMapper.createMap","AutoMapperJs.AutoMapper.map","AutoMapperJs.AutoMapper.mapAsync","AutoMapperJs.AutoMapper.assertConfigurationIsValid","AutoMapperJs.AutoMapper.createMapForMember","AutoMapperJs.AutoMapper.createMapForMemberFindMember","AutoMapperJs.AutoMapper.createMapForMemberHandleMappingFunction","AutoMapperJs.AutoMapper.createMapForMemberHandleSyncMappingFunction","AutoMapperJs.AutoMapper.createMapForMemberHandleAsyncMappingFunction","AutoMapperJs.AutoMapper.createMapForSourceMember","AutoMapperJs.AutoMapper.createMapForAllMembers","AutoMapperJs.AutoMapper.createMapIgnoreAllNonExisting","AutoMapperJs.AutoMapper.createMapConvertToType","AutoMapperJs.AutoMapper.createMapConvertUsing","AutoMapperJs.AutoMapper.createMapWithProfile","AutoMapperJs.AutoMapper.createMapWithProfileMergeMappings","AutoMapperJs.AutoMapper.mapInternal","AutoMapperJs.AutoMapper.mapArray","AutoMapperJs.AutoMapper.mapItem","AutoMapperJs.AutoMapper.mapItemUsingTypeConverter","AutoMapperJs.AutoMapper.mapItemCreateDestinationObject","AutoMapperJs.AutoMapper.mapProperty","AutoMapperJs.AutoMapper.mapGetDestinationPropertyName","AutoMapperJs.AutoMapper.mapSetValue","AutoMapperJs.AutoMapper.getKey"],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/arcady-automapper-interfaces.d.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    type ICMChainFunc = IAutoMapperCreateMapChainingFunctions;\r\n\r\n    /**\r\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\r\n     * .NET AutoMapper library is the pursuit of this implementation.\r\n     */\r\n    export class AutoMapper {\r\n        private static instance = new AutoMapper();\r\n\r\n        private profiles: { [name: string]: IProfile };\r\n        private mappings: { [key: string]: IMapping };\r\n\r\n        /**\r\n         * Creates a new AutoMapper instance. This class is intended to be a Singleton.\r\n         * Do not use the constructor directly from code. Use getInstance() function instead.\r\n         * @constructor\r\n         */\r\n        constructor() {\r\n            if (AutoMapper.instance) {\r\n                return AutoMapper.instance;\r\n                //var profiles = AutoMapper.instance.profiles;\r\n                //var mappings = AutoMapper.instance.mappings;\r\n\r\n                //AutoMapper.instance = this;\r\n\r\n                //this.profiles = profiles;\r\n                //this.mappings = mappings;\r\n            } else {\r\n                AutoMapper.instance = this;\r\n\r\n                this.profiles = {};\r\n                this.mappings = {};\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets AutoMapper Singleton instance.\r\n         * @returns {Core.AutoMapper}\r\n         */\r\n        public static getInstance(): AutoMapper {\r\n            return AutoMapper.instance;\r\n        }\r\n\r\n        /**\r\n         * Initializes the mapper with the supplied configuration.\r\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\r\n         */\r\n        public initialize(configFunction: (config: IConfiguration) => void): void {\r\n            var that = this;\r\n\r\n            // NOTE BL casting to any is needed, since TS does not fully support method overloading.\r\n            var configuration: IConfiguration = <any>{\r\n                addProfile: (profile: IProfile) : void => {\r\n                    profile.configure();\r\n                    that.profiles[profile.profileName] = profile;\r\n                },\r\n                createMap: function (sourceKey: string, destinationKey: string): ICMChainFunc {\r\n                    // pass through using arguments to keep createMap's currying support fully functional.\r\n                    return that.createMap.apply(that, arguments);\r\n                }\r\n            };\r\n            configFunction(configuration);\r\n        }\r\n\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        public createMap(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any)): ICMChainFunc {\r\n            // provide currying support.\r\n            if (arguments.length < 2) { // this.createMap.length) {\r\n                return AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var sourceKey = this.getKey(sourceKeyOrType);\r\n            var destinationKey = this.getKey(destinationKeyOrType);\r\n\r\n            var mappingKey = sourceKey + destinationKey;\r\n\r\n            // create a mapping object for the given keys\r\n            var mapping: IMapping = {\r\n                sourceKey: sourceKey,\r\n                destinationKey: destinationKey,\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                forMemberMappings: {},\r\n                typeConverterFunction: undefined,\r\n                mapItemFunction: this.mapItem,\r\n                sourceTypeClass: (typeof sourceKeyOrType === 'string' ? undefined : sourceKeyOrType),\r\n                destinationTypeClass: (typeof destinationKeyOrType === 'string' ? undefined : destinationKeyOrType),\r\n                profile: undefined,\r\n                async: false\r\n            };\r\n            this.mappings[mappingKey] = mapping;\r\n\r\n            // return an object with available 'sub' functions to create a fluent interface / method chaining \r\n            // (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentApiFuncs: ICMChainFunc = {\r\n                forMember: (destinationProperty: string,\r\n                            valueOrFunction: any|((opts: IMemberConfigurationOptions) => any)|((opts: IMemberConfigurationOptions, cb: IMemberCallback) => void)\r\n                           ) : ICMChainFunc => this.createMapForMember(mapping, fluentApiFuncs, destinationProperty, valueOrFunction),\r\n                forSourceMember: (sourceProperty: string,\r\n                                  configFunction: ((opts: ISourceMemberConfigurationOptions) => any)|((opts: ISourceMemberConfigurationOptions, cb: IMemberCallback) => void)\r\n                                 ) : ICMChainFunc => this.createMapForSourceMember(mapping, fluentApiFuncs, sourceProperty, configFunction),\r\n                forAllMembers: (func: (destinationObject: any, destinationPropertyName: string, value: any) => void) : ICMChainFunc =>\r\n                    this.createMapForAllMembers(mapping, fluentApiFuncs, func),\r\n                ignoreAllNonExisting: () : ICMChainFunc =>\r\n                    this.createMapIgnoreAllNonExisting(mapping, fluentApiFuncs),\r\n                convertToType: (typeClass: new () => any) : ICMChainFunc =>\r\n                    this.createMapConvertToType(mapping, fluentApiFuncs, typeClass),\r\n                convertUsing: (typeConverterClassOrFunction: ((resolutionContext: IResolutionContext) => any)|TypeConverter|(new() => TypeConverter)) : void =>\r\n                    this.createMapConvertUsing(mapping, typeConverterClassOrFunction),\r\n                withProfile: (profileName: string) : void => this.createMapWithProfile(mapping, profileName)\r\n            };\r\n            return fluentApiFuncs;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any), sourceObject: any): any {\r\n            if (arguments.length === 3) {\r\n                let sourceKey = this.getKey(sourceKeyOrType);\r\n                let destinationKey = this.getKey(destinationKeyOrType);\r\n                let mapping: IMapping = this.mappings[sourceKey + destinationKey];\r\n\r\n                if (!mapping) {\r\n                    throw new Error(`Could not find map object with a source of ${sourceKey} and a destination of ${destinationKey}`);\r\n                }\r\n\r\n                return this.mapInternal(mapping, sourceObject);\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                let sourceKey = this.getKey(sourceKeyOrType);\r\n                let destinationKey = this.getKey(destinationKeyOrType);\r\n                let mapping: IMapping = this.mappings[sourceKey + destinationKey];\r\n                return (srcObj: any) => this.mapInternal(mapping, srcObj);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new() => any), srcObj: any) => this.map(sourceKeyOrType, dstKey, srcObj);\r\n            }\r\n\r\n            return (srcKey: string | (new() => any), dstKey: string | (new() => any), srcObj: any) => this.map(srcKey, dstKey, srcObj);\r\n        }\r\n\r\n        /**\r\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\r\n         */\r\n        public mapAsync(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any), sourceObject: any, callback: IMapCallback): any {\r\n            if (arguments.length === 4) {\r\n                let sourceKey = this.getKey(sourceKeyOrType);\r\n                let destinationKey = this.getKey(destinationKeyOrType);\r\n                let mapping: IMapping = this.mappings[sourceKey + destinationKey];\r\n\r\n                if (!mapping) {\r\n                    throw new Error(`Could not find map object with a source of ${sourceKey} and a destination of ${destinationKey}`);\r\n                }\r\n\r\n                AsyncAutoMapper.getInstance().mapAsyncInternal(mapping, sourceObject, callback);\r\n                return;\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                let sourceKey = this.getKey(sourceKeyOrType);\r\n                let destinationKey = this.getKey(destinationKeyOrType);\r\n                let mapping: IMapping = this.mappings[sourceKey + destinationKey];\r\n                return (srcObj: any, callback: IMapCallback) => AsyncAutoMapper.getInstance().mapAsyncInternal(mapping, srcObj, callback);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new() => any), srcObj: any, callback: IMapCallback) => this.mapAsync(sourceKeyOrType, dstKey, srcObj, callback);\r\n            }\r\n\r\n            return (srcKey: string | (new() => any), dstKey: string | (new() => any), srcObj: any) => this.mapAsync(srcKey, dstKey, srcObj, callback);\r\n        }\r\n\r\n        /**\r\n         * Validates mapping configuration by dry-running. Since JS does not\r\n         * fully support typing, it only checks if properties match on both\r\n         * sides. The function needs IMapping.sourceTypeClass and \r\n         * IMapping.destinationTypeClass to function.\r\n         * @param {boolean} strictMode Whether or not to fail when properties\r\n         *                             sourceTypeClass or destinationTypeClass\r\n         *                             are unavailable. \r\n         */\r\n        public assertConfigurationIsValid(strictMode: boolean = true): void {\r\n            AutoMapperValidator.assertConfigurationIsValid(this.mappings, strictMode);\r\n        }\r\n\r\n        /**\r\n         * Customize configuration for an individual destination member.\r\n         * @param {IMapping} mapping The mapping configuration for the current mapping keys/types.\r\n         * @param {IAutoMapperCreateMapChainingFunctions} toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param {string} destinationProperty The destination member property name.\r\n         * @param valueOrFunction The value or function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForMember(mapping: IMapping,\r\n                                   toReturnFunctions: ICMChainFunc,\r\n                                   destinationProperty: string,\r\n                                   valueOrFunction: any): ICMChainFunc {\r\n            // find existing mapping for member\r\n            var originalSourcePropertyName: string = undefined;\r\n            var memberMapping: IForMemberMapping = this.createMapForMemberFindMember(mapping, destinationProperty);\r\n            if (memberMapping !== null && memberMapping !== undefined) {\r\n                // do not add additional mappings to a member that is already ignored.\r\n                if (memberMapping.ignore) {\r\n                    return toReturnFunctions;\r\n                }\r\n\r\n                // store original source property name (cloned)\r\n                originalSourcePropertyName = `${memberMapping.sourceProperty}`;\r\n            } else {\r\n                // set defaults for member mapping\r\n                memberMapping = {\r\n                    sourceProperty: destinationProperty,\r\n                    destinationProperty: destinationProperty,\r\n                    sourceMapping: false,\r\n                    mappingValuesAndFunctions: new Array<any>(),\r\n                    ignore: false,\r\n                    async: false,\r\n                    conditionFunction: undefined\r\n                };\r\n            }\r\n\r\n            if (typeof valueOrFunction === 'function') {\r\n                this.createMapForMemberHandleMappingFunction(mapping, memberMapping, valueOrFunction);\r\n            } else {\r\n                memberMapping.mappingValuesAndFunctions.push(valueOrFunction);\r\n            }\r\n\r\n            // if this createMapForMember operation changes the source member (e.g. when mapFrom was specified), we delete\r\n            // the existing member mapping from the dictionary. After that, we add the merged member mapping to the dictionary\r\n            // with the new source member as key.\r\n            if (!originalSourcePropertyName) {\r\n                mapping.forMemberMappings[memberMapping.sourceProperty] = memberMapping;\r\n            } else if (originalSourcePropertyName !== memberMapping.sourceProperty) {\r\n                delete mapping.forMemberMappings[originalSourcePropertyName];\r\n                mapping.forMemberMappings[memberMapping.sourceProperty] = memberMapping;\r\n            }\r\n\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Try to locate an existing member mapping.\r\n         * @param {IMapping} mapping The mapping configuration for the current mapping keys/types.\r\n         * @param {string} destinationProperty The destination member property name.\r\n         * @returns {IForMemberMapping} Existing member mapping if found; otherwise, null.\r\n         */\r\n        private createMapForMemberFindMember(mapping: IMapping, destinationPropertyName: string): IForMemberMapping {\r\n            for (let property in mapping.forMemberMappings) {\r\n                if (!mapping.forMemberMappings.hasOwnProperty(property)) {\r\n                    continue;\r\n                }\r\n\r\n                let memberMapping = mapping.forMemberMappings[property];\r\n\r\n                if (memberMapping.destinationProperty === destinationPropertyName) {\r\n                    return memberMapping;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private createMapForMemberHandleMappingFunction(mapping: IMapping,\r\n                                                        memberMapping: IForMemberMapping,\r\n                                                        memberConfigFunc: ((opts: IMemberConfigurationOptions) => any) |\r\n                                                                          ((opts: IMemberConfigurationOptions, cb: IMemberCallback) => void)\r\n                                                       ): void {\r\n            var memberConfigFuncParameters = AutoMapperHelper.getFunctionParameters(memberConfigFunc);\r\n            if (memberConfigFuncParameters.length <= 1) {\r\n                this.createMapForMemberHandleSyncMappingFunction(memberMapping, <(opts: IMemberConfigurationOptions) => any>memberConfigFunc);\r\n            } else {\r\n                this.createMapForMemberHandleAsyncMappingFunction(mapping, memberMapping, <(opts: IMemberConfigurationOptions, cb: IMemberCallback) => void>memberConfigFunc);\r\n            }\r\n        }\r\n\r\n        private createMapForMemberHandleSyncMappingFunction(memberMapping: IForMemberMapping, memberConfigFunc: (opts: IMemberConfigurationOptions) => any): void {\r\n            var addMappingValueOrFunction = true;\r\n\r\n            // Since we are calling the valueOrFunction function to determine whether to ignore or map from another property, we\r\n            // want to prevent the call to be error prone when the end user uses the '(opts)=> opts.sourceObject.sourcePropertyName'\r\n            // syntax. We don't actually have a source object when creating a mapping; therefore, we 'stub' a source object for the\r\n            // function call.\r\n            var sourceObject: any = {};\r\n            sourceObject[memberMapping.sourceProperty] = {};\r\n\r\n            // calling the function will result in calling our stubbed ignore() and mapFrom() functions if used inside the function.\r\n            const configFuncOptions: IMemberConfigurationOptions = {\r\n                ignore: (): void => {\r\n                    // an ignored member effectively has no mapping values / functions. Remove potentially existing values / functions.\r\n                    memberMapping.ignore = true;\r\n                    memberMapping.sourceProperty = memberMapping.destinationProperty; // in case someone really tried mapFrom before.\r\n                    memberMapping.mappingValuesAndFunctions = new Array<any>();\r\n                    addMappingValueOrFunction = false;\r\n                },\r\n                condition: (predicate: ((sourceObject: any) => boolean)): void => {\r\n                    memberMapping.conditionFunction = predicate;\r\n                },\r\n                mapFrom: (sourcePropertyName: string): void => {\r\n                    memberMapping.sourceProperty = sourcePropertyName;\r\n                },\r\n                sourceObject: sourceObject,\r\n                sourcePropertyName: memberMapping.sourceProperty,\r\n                destinationPropertyValue: {}\r\n            };\r\n\r\n            // actually call the (stubbed) member config function.\r\n            try {\r\n                memberConfigFunc(configFuncOptions);\r\n            } catch (err) {\r\n                // not foreseeable, but no problem at all (possible by design, like with the opts.condition() and mappingValuesAndFunctions \r\n                // methods). We have to catch all potential errors from calling the function, since we cannot predict which goals the end \r\n                // user tries do reach with the stubbed sourceObject property.\r\n            }\r\n\r\n            if (addMappingValueOrFunction) {\r\n                memberMapping.mappingValuesAndFunctions.push(memberConfigFunc);\r\n            }\r\n        }\r\n\r\n        private createMapForMemberHandleAsyncMappingFunction(mapping: IMapping,\r\n                                                             memberMapping: IForMemberMapping,\r\n                                                             memberConfigFunc: (opts: IMemberConfigurationOptions, cb: IMemberCallback) => void\r\n                                                            ): void {\r\n            mapping.async = true;\r\n            memberMapping.async = true;\r\n            memberMapping.mappingValuesAndFunctions.push(memberConfigFunc);\r\n        }\r\n        /**\r\n         * Customize configuration for an individual source member.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param sourceProperty The source member property name.\r\n         * @param memberConfigFunc The function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForSourceMember(mapping: IMapping,\r\n                                         toReturnFunctions: ICMChainFunc,\r\n                                         sourceProperty: string,\r\n                                         memberConfigFunc: ((opts: ISourceMemberConfigurationOptions) => any) |\r\n                                                           ((opts: ISourceMemberConfigurationOptions, cb: IMemberCallback) => void)\r\n                                        ): ICMChainFunc {\r\n            // set defaults\r\n            var ignore = false;\r\n            var destinationProperty = sourceProperty;\r\n            var async = false;\r\n\r\n            if (typeof memberConfigFunc !== 'function') {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one options parameter.');\r\n            }\r\n\r\n            if (AutoMapperHelper.getFunctionParameters(memberConfigFunc).length <= 1) {\r\n                var configFuncOptions = {\r\n                    ignore: (): void => {\r\n                        ignore = true;\r\n                        destinationProperty = undefined;\r\n                    }\r\n                };\r\n                (<(opts: ISourceMemberConfigurationOptions) => any>memberConfigFunc)(configFuncOptions);\r\n            } else {\r\n                async = true;\r\n            }\r\n\r\n            var memberMapping = mapping.forMemberMappings[sourceProperty];\r\n            if (memberMapping) {\r\n                if (ignore) {\r\n                    memberMapping.ignore = true;\r\n                    memberMapping.async = false;\r\n                    memberMapping.mappingValuesAndFunctions = new Array<any>();\r\n                } else {\r\n                    memberMapping.async = async;\r\n                    memberMapping.mappingValuesAndFunctions.push(memberConfigFunc);\r\n                }\r\n            } else {\r\n                mapping.forMemberMappings[sourceProperty] = {\r\n                    sourceProperty: sourceProperty,\r\n                    destinationProperty: destinationProperty,\r\n                    sourceMapping: true,\r\n                    mappingValuesAndFunctions: [memberConfigFunc],\r\n                    ignore: ignore,\r\n                    async: async,\r\n                    conditionFunction: undefined\r\n                };\r\n            }\r\n\r\n            if (async ===  true) {\r\n                mapping.async = true;\r\n            }\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Customize configuration for all destination members.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param func The function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForAllMembers(mapping: IMapping,\r\n                                       toReturnFunctions: ICMChainFunc,\r\n                                       func: (destinationObject: any, destinationPropertyName: string, value: any) => void\r\n                                      ): ICMChainFunc {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Ignore all members not specified explicitly.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapIgnoreAllNonExisting(mapping: IMapping, toReturnFunctions: ICMChainFunc): ICMChainFunc {\r\n            mapping.ignoreAllNonExisting = true;\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Specify to which class type AutoMapper should convert. When specified, AutoMapper will create an instance of the given type, instead of returning a new object literal.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param typeClass The destination type class.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapConvertToType(mapping: IMapping,\r\n                                       toReturnFunctions: ICMChainFunc,\r\n                                       typeClass: new () => any): ICMChainFunc {\r\n            if (mapping.destinationTypeClass) {\r\n                if (mapping.destinationTypeClass === typeClass) {\r\n                    return toReturnFunctions;\r\n                }\r\n\r\n                throw new Error('Destination type class can only be set once.');\r\n            }\r\n\r\n            mapping.destinationTypeClass = typeClass;\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Skip normal member mapping and convert using a custom type converter (instantiated during mapping).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param typeConverterClassOrFunction The converter class or function to use when converting.\r\n         */\r\n        private createMapConvertUsing(mapping: IMapping,\r\n                                      typeConverterClassOrFunction: ((resolutionContext: IResolutionContext) => any) |\r\n                                                                     TypeConverter |\r\n                                                                     (new() => TypeConverter)): void {\r\n            var typeConverterFunction: (resolutionContext: IResolutionContext) => any;\r\n\r\n            // 1. check if a function with one parameter is provided; if so, assume it to be the convert function.\r\n            // 2. check if an instance of TypeConverter is provided; in that case, there will be a convert function.\r\n            // 3. assume we are dealing with a class definition, instantiate it and store its convert function.\r\n            // [4. okay, really? the dev providing typeConverterClassOrFunction appears to be an idiot - fire him/her :P .]\r\n            try {\r\n                if (typeConverterClassOrFunction instanceof TypeConverter) {\r\n                    typeConverterFunction = typeConverterClassOrFunction.convert;\r\n                } else if (AutoMapperHelper.getFunctionParameters(<(resolutionContext: IResolutionContext) => any>typeConverterClassOrFunction).length === 1) {\r\n                    typeConverterFunction = <(resolutionContext: IResolutionContext) => any>typeConverterClassOrFunction;\r\n                } else {\r\n                    // ReSharper disable InconsistentNaming\r\n                    typeConverterFunction = (<TypeConverter>new (<new() => TypeConverter>typeConverterClassOrFunction)()).convert;\r\n                    // ReSharper restore InconsistentNaming\r\n                }\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. Exception: ${e}`);\r\n            }\r\n\r\n            if (!typeConverterFunction || AutoMapperHelper.getFunctionParameters(typeConverterFunction).length !== 1) {\r\n                throw new Error('The value provided for typeConverterClassOrFunction is invalid, because it does not provide exactly one (resolutionContext) parameter.');\r\n            }\r\n\r\n            mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>typeConverterFunction;\r\n            mapping.mapItemFunction = this.mapItemUsingTypeConverter;\r\n        }\r\n\r\n        /**\r\n         * Assign a profile to the current type map. \r\n         * @param {IMapping} mapping The mapping configuration for the current mapping keys/types.\r\n         * @param {string} profileName The profile name of the profile to assign.\r\n         */\r\n        private createMapWithProfile(mapping: IMapping, profileName: string): void {\r\n            // check if given profile exists\r\n            var profile = this.profiles[profileName];\r\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\r\n                throw new Error(`Could not find profile with profile name '${profileName}'.`);\r\n            }\r\n\r\n            mapping.profile = profile;\r\n            // merge mappings\r\n            this.createMapWithProfileMergeMappings(mapping, profileName);\r\n        }\r\n\r\n        /**\r\n         * Merge original mapping object with the assigned profile's mapping object.\r\n         * @param {IMapping} mapping The mapping configuration for the current mapping keys/types.\r\n         * @param {string} profileName The profile name of the profile to assign.\r\n         */\r\n        private createMapWithProfileMergeMappings(mapping: IMapping,\r\n                                     profileName: string): void {\r\n\r\n            var profileMappingKey = `${profileName}=>${mapping.sourceKey}${profileName}=>${mapping.destinationKey}`;\r\n            var profileMapping: IMapping = this.mappings[profileMappingKey];\r\n            if (!profileMapping) {\r\n                return;\r\n            }\r\n\r\n            // append forAllMemberMappings calls to the original array.\r\n            if (profileMapping.forAllMemberMappings.length > 0) {\r\n                mapping.forAllMemberMappings.push(...profileMapping.forAllMemberMappings);\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.typeConverterFunction) {\r\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.destinationTypeClass) {\r\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\r\n            }\r\n\r\n            // walk through all the profile's property mappings\r\n            for (let propertyName in profileMapping.forMemberMappings) {\r\n                if (!profileMapping.forMemberMappings.hasOwnProperty(propertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                let profilePropertyMapping = profileMapping.forMemberMappings[propertyName];\r\n\r\n                // try to find an existing mapping for this property mapping\r\n                let existingPropertyMapping = this.createMapForMemberFindMember(mapping, profilePropertyMapping.destinationProperty);\r\n                if (existingPropertyMapping) {\r\n                    // in which case, we overwrite that one with the profile's property mapping.\r\n                    // okay, maybe a bit rude, but real merging is pretty complex and you should\r\n                    // probably not want to combine normal and profile createMap.forMember calls.\r\n                    delete mapping.forMemberMappings[existingPropertyMapping.sourceProperty];\r\n                    mapping.forMemberMappings[profilePropertyMapping.sourceProperty] = profilePropertyMapping;\r\n                }\r\n            }\r\n        }\r\n\r\n        private mapInternal(mapping: IMapping, sourceObject: any): any {\r\n            if (mapping.async) {\r\n                throw new Error('Support for asynchronous mapping is not implemented in synchronous map() call. Please use mapAsync().');\r\n            }\r\n\r\n            if (sourceObject instanceof Array) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return mapping.mapItemFunction.call(this, mapping, sourceObject);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceArray The source array to map.\r\n         * @returns {Array<any>} Destination array.\r\n         */\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            // create empty destination array.\r\n            var destinationArray = new Array<any>();\r\n\r\n            for (let index = 0, length = sourceArray.length; index < length; index++) {\r\n                let sourceObject = sourceArray[index];\r\n\r\n                let destinationObject = mapping.mapItemFunction.call(this, mapping, sourceObject, index);\r\n                if (destinationObject) {\r\n                    destinationArray.push(destinationObject);\r\n                }\r\n            }\r\n\r\n            return destinationArray;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param arrayIndex The array index number, if this is an array being mapped.\r\n         * @returns {any} Destination object.\r\n         */\r\n        private mapItem(mapping: IMapping, sourceObject: any, arrayIndex?: number): any {\r\n            var destinationObject = this.mapItemCreateDestinationObject(mapping.destinationTypeClass);\r\n\r\n            for (let sourcePropertyName in sourceObject) {\r\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                this.mapProperty(mapping, sourceObject, sourcePropertyName, destinationObject);\r\n            }\r\n\r\n            return destinationObject;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param arrayIndex The array index number, if this is an array being mapped.\r\n         * @returns {any} Destination object.\r\n         */\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, arrayIndex?: number): any {\r\n            var destinationObject = this.mapItemCreateDestinationObject(mapping.destinationTypeClass);\r\n\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            return mapping.typeConverterFunction(resolutionContext);\r\n        }\r\n\r\n        private mapItemCreateDestinationObject(destinationTypeClass: new() => any): any {\r\n            // create empty destination object.\r\n            return destinationTypeClass\r\n                ? new destinationTypeClass()\r\n                : {};\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param sourcePropertyName The source property to map.\r\n         * @param destinationObject The destination object to map to.\r\n         */\r\n        private mapProperty(mapping: IMapping, sourceObject: any, sourcePropertyName: string, destinationObject: any): void {\r\n            var propertyMapping = mapping.forMemberMappings[sourcePropertyName];\r\n            if (propertyMapping) {\r\n                // a forMember mapping exists\r\n\r\n                var {\r\n                    ignore,\r\n                    conditionFunction,\r\n                    destinationProperty,\r\n                    mappingValuesAndFunctions\r\n                } = propertyMapping;\r\n\r\n                // ignore ignored properties\r\n                if (ignore) {\r\n                    return;\r\n                }\r\n\r\n                // check for condition function\r\n                if (conditionFunction) {\r\n                    // and, if there, return when the condition is not met.\r\n                    if (conditionFunction(sourceObject) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                var memberConfigurationOptions: IMemberConfigurationOptions = {\r\n                    mapFrom: (): void => {//sourceMemberKey: string) {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    condition: (predicate: ((sourceObject: any) => boolean)): void => {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    sourceObject: sourceObject,\r\n                    sourcePropertyName: sourcePropertyName,\r\n                    destinationPropertyValue: sourceObject[sourcePropertyName]\r\n                };\r\n\r\n                for (let mappingValueOrFunction of mappingValuesAndFunctions) {\r\n                    let destinationPropertyValue: any;\r\n\r\n                    if (typeof mappingValueOrFunction === 'function') {\r\n                        destinationPropertyValue = mappingValueOrFunction(memberConfigurationOptions);\r\n                        if (typeof destinationPropertyValue === 'undefined') {\r\n                            destinationPropertyValue = memberConfigurationOptions.destinationPropertyValue;\r\n                        }\r\n                    } else {\r\n                        // mappingValueOrFunction is a value\r\n                        destinationPropertyValue = mappingValueOrFunction;\r\n                    }\r\n\r\n                    memberConfigurationOptions.destinationPropertyValue = destinationPropertyValue;\r\n                }\r\n\r\n                this.mapSetValue(mapping, destinationObject, propertyMapping.destinationProperty, memberConfigurationOptions.destinationPropertyValue);\r\n            } else {\r\n                // no forMember mapping exists, auto map properties ...\r\n\r\n                // ... except for the situation where ignoreAllNonExisting is specified.\r\n                if (mapping.ignoreAllNonExisting) {\r\n                    return;\r\n                }\r\n\r\n                // use profile mapping when specified; otherwise, specify source property name as destination property name.\r\n                let destinationPropertyName: string;\r\n                if (mapping.profile) {\r\n                    destinationPropertyName = this.mapGetDestinationPropertyName(mapping.profile, sourcePropertyName);\r\n                } else {\r\n                    destinationPropertyName = sourcePropertyName;\r\n                }\r\n\r\n                this.mapSetValue(mapping, destinationObject, destinationPropertyName, sourceObject[sourcePropertyName]);\r\n            }\r\n        }\r\n\r\n        private mapGetDestinationPropertyName(profile: IProfile, sourcePropertyName: string): string {\r\n            // TODO BL no support yet for INamingConvention.splittingCharacter\r\n\r\n            try {\r\n                // First, split the source property name based on the splitting expression.\r\n                // TODO BL Caching of RegExp splitting!\r\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\r\n\r\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\r\n                for (let index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\r\n                    if (sourcePropertyNameParts[index] === '') {\r\n                        sourcePropertyNameParts.splice(index, 1);\r\n                    }\r\n                }\r\n\r\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\r\n            } catch (error) {\r\n                return sourcePropertyName;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the mapped value on the destination object, either direct or via the (optionally) supplied forAllMembers function(s).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param propertyMapping The mapping property configuration for the current property.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param destinationPropertyValue The destination value.\r\n         */\r\n        private mapSetValue(mapping: IMapping, destinationObject: any, destinationPropertyName: string, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (let forAllMemberMapping of mapping.forAllMemberMappings) {\r\n                    forAllMemberMapping(destinationObject, destinationPropertyName, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationPropertyName] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        private getKey(keyStringOrType: string | (new() => any)): string {\r\n            if (typeof keyStringOrType === 'string') {\r\n                return keyStringOrType;\r\n            } else {\r\n                return AutoMapperHelper.getClassName(keyStringOrType);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.AutoMapper = ((app: any) => {\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);"],"sourceRoot":"/source/"}