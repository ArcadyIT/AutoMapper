{"version":3,"sources":["AutoMapper.ts"],"names":[],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapperEnumerations.ts\" />\r\n/// <reference path=\"AutoMapperBase.ts\" />\r\n/// <reference path=\"AsyncAutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    // interface shorthands\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n    type IDMCO = IMemberConfigurationOptions;\r\n    type ISMCO = ISourceMemberConfigurationOptions;\r\n    type IMC = IMemberCallback;\r\n    type IRC = IResolutionContext;\r\n    type TC = TypeConverter;\r\n\r\n    // method overload shorthands\r\n    type stringOrClass = string | (new () => any);\r\n    type forMemberValueOrFunction = any | ((opts: IDMCO) => any) | ((opts: IDMCO, cb: IMC) => void);\r\n    type convertUsingClassOrInstanceOrFunction = ((ctx: IRC) => any) | ((ctx: IRC, callback: IMapCallback) => void) | TC | (new () => TC);\r\n\r\n    export class AutoMapper extends AutoMapperBase {\r\n        private static _instance = new AutoMapper();\r\n\r\n        private _profiles: { [name: string]: IProfile };\r\n        private _mappings: { [key: string]: IMapping };\r\n\r\n        private _asyncMapper: AsyncAutoMapper;\r\n\r\n        public static getInstance(): AutoMapper {\r\n            return AutoMapper._instance;\r\n        }\r\n\r\n        /**\r\n         * This class is intended to be a Singleton. Preferrably use getInstance() \r\n         * function instead of using the constructor directly from code.\r\n         */\r\n        constructor() {\r\n            super();\r\n\r\n            if (AutoMapper._instance) {\r\n                return AutoMapper._instance;\r\n            } else {\r\n                AutoMapper._instance = this;\r\n\r\n                this._profiles = {};\r\n                this._mappings = {};\r\n\r\n                this._asyncMapper = new AsyncAutoMapper();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Initializes the mapper with the supplied configuration.\r\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\r\n         */\r\n        public initialize(configFunction: (config: IConfiguration) => void): void {\r\n            var that = this;\r\n\r\n            var configuration: IConfiguration = <any>{\r\n                addProfile: (profile: IProfile): void => {\r\n                    profile.configure();\r\n                    that._profiles[profile.profileName] = profile;\r\n                },\r\n                createMap: function(sourceKey: string, destinationKey: string): IFluentFunc {\r\n                    // pass through using arguments to keep createMap's currying support fully functional.\r\n                    return that.createMap.apply(that, arguments);\r\n                }\r\n            };\r\n\r\n            configFunction(configuration);\r\n        }\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.ICreateMapFluentFunctions}\r\n         */\r\n        public createMap(sourceKeyOrType: string | (new () => any), destinationKeyOrType: string | (new () => any)): IFluentFunc {\r\n            // provide currying support.\r\n            if (arguments.length < 2) {\r\n                return AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\r\n\r\n            return this.createMapGetFluentApiFunctions(mapping);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKeyOrType: stringOrClass, destinationKeyOrType: stringOrClass, sourceObject: any): any {\r\n            if (arguments.length === 3) {\r\n                return this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                return (srcObj: any) => this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new () => any), srcObj: any) => this.map(sourceKeyOrType, dstKey, srcObj);\r\n            }\r\n\r\n            return (srcKey: string | (new () => any), dstKey: string | (new () => any), srcObj: any) => this.map(srcKey, dstKey, srcObj);\r\n        }\r\n\r\n        /**\r\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\r\n         */\r\n        public mapAsync(sourceKeyOrType: string | (new () => any), destinationKeyOrType: string | (new () => any), sourceObject: any, callback: IMapCallback): any {\r\n            switch (arguments.length) {\r\n                case 4:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject, callback);\r\n                case 3:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject);\r\n                case 2:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType);\r\n                case 1:\r\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType);\r\n                default:\r\n                    throw new Error('The mapAsync function expects between 1 and 4 parameters, you provided ' + arguments.length + '.');\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\r\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\r\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable. \r\n         */\r\n        public assertConfigurationIsValid(strictMode: boolean = true): void {\r\n            AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\r\n        }\r\n\r\n        private createMapForMember(parameters: ICreateMapParameters): IFluentFunc {\r\n            var { mapping, destinationProperty, conversionValueOrFunction, sourceMapping, fluentFunctions } = parameters;\r\n\r\n            var metadata = AutoMapperHelper.getMappingMetadataFromConfigFunction(destinationProperty, conversionValueOrFunction, sourceMapping);\r\n\r\n            var property: IProperty;\r\n            if (!sourceMapping) {\r\n                property = this.getPropertyByDestinationProperty(mapping.properties, destinationProperty);\r\n            }\r\n\r\n            if (!property) {\r\n                property = this.getOrCreateProperty({\r\n                    propertyNameParts: metadata.source.split('.'),\r\n                    mapping: mapping,\r\n                    propertyArray: mapping.properties,\r\n                    parent: null,\r\n                    destination: destinationProperty,\r\n                    sourceMapping: sourceMapping\r\n                });\r\n            }\r\n\r\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\r\n                return fluentFunctions;\r\n            }\r\n\r\n            if (metadata.async) {\r\n                this._asyncMapper.createMapForMember(property, <(opts: IDMCO, cb: IMemberCallback) => void>conversionValueOrFunction, metadata);\r\n                return fluentFunctions;\r\n            }\r\n\r\n            this.createMapForMemberHandleMapFrom(property, metadata);\r\n            property.conditionFunction = metadata.condition;\r\n            property.conversionValuesAndFunctions.push(conversionValueOrFunction);\r\n\r\n            return fluentFunctions;\r\n        }\r\n\r\n        private createMapForMemberHandleMapFrom(property: IProperty, metadata: IMemberMappingMetaData): void {\r\n            if (metadata.source === metadata.destination) {\r\n                return;\r\n            }\r\n\r\n            var { mapping, root } = property.metadata;\r\n\r\n            var sourceNameParts = metadata.source.split('.');\r\n            if (sourceNameParts.length === property.level) {\r\n                this.updatePropertyName(sourceNameParts, property);\r\n                return;\r\n            }\r\n\r\n            // check if only one destination on property root. in that case, rebase property and overwrite root.\r\n            if (root.metadata.destinationCount !== 1) {\r\n                throw new Error('Rebasing properties with multiple destinations is not yet implemented.');\r\n            }\r\n\r\n            var propertyRootIndex = mapping.properties.indexOf(root);\r\n            mapping.properties[propertyRootIndex] = undefined;\r\n            var propArray: IProperty[] = [];\r\n            var newProperty = this.getOrCreateProperty({\r\n                propertyNameParts: metadata.source.split('.'),\r\n                mapping: mapping,\r\n                propertyArray: propArray,\r\n                destination: metadata.destination,\r\n                sourceMapping: metadata.sourceMapping\r\n            });\r\n\r\n            newProperty.conditionFunction = property.conditionFunction;\r\n            newProperty.conversionValuesAndFunctions = property.conversionValuesAndFunctions;\r\n            mapping.properties[propertyRootIndex] = propArray[0];\r\n        }\r\n\r\n        private updatePropertyName(sourceNameParts: string[], property: IProperty): void {\r\n            property.name = sourceNameParts[sourceNameParts.length - 1];\r\n\r\n            if (sourceNameParts.length === 1) {\r\n                return;\r\n            }\r\n\r\n            this.updatePropertyName(sourceNameParts.splice(0, 1), property.metadata.parent);\r\n        }\r\n\r\n        private createMapForMemberHandleIgnore(property: IProperty, metadata: IMemberMappingMetaData): boolean {\r\n            if (property.ignore || metadata.ignore) {\r\n                // source name will always be destination name when ignoring.\r\n                property.name = metadata.destination;\r\n                property.ignore = true;\r\n                property.async = false;\r\n                property.destinations = null;\r\n                property.conversionValuesAndFunctions = [];\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private getPropertyByDestinationProperty(properties: IProperty[], destinationPropertyName: string): IProperty {\r\n            if (properties === null || properties === undefined) {\r\n                return null;\r\n            }\r\n\r\n            for (let srcProp of properties) {\r\n                if (srcProp.metadata.destinations !== null && srcProp.metadata.destinations !== undefined) {\r\n                    for (let destination in srcProp.metadata.destinations) {\r\n                        if (destination === destinationPropertyName) {\r\n                            return srcProp.metadata.destinations[destination].source;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let childProp = this.getPropertyByDestinationProperty(srcProp.children, destinationPropertyName);\r\n                if (childProp != null) {\r\n                    return childProp;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private getOrCreateProperty(parameters: IGetOrCreatePropertyParameters): IProperty {\r\n            var { propertyNameParts, mapping, parent, propertyArray, destination, sourceMapping } = parameters;\r\n\r\n            var name = propertyNameParts[0];\r\n\r\n            var property = this.getPropertyFromArray(name, propertyArray);\r\n            if (!property) {\r\n                property = this.createProperty({\r\n                    name: name,\r\n                    parent: parent,\r\n                    propertyArray: propertyArray,\r\n                    sourceMapping: sourceMapping,\r\n                    mapping: mapping\r\n                });\r\n            }\r\n\r\n            if (propertyNameParts.length === 1) {\r\n                this.addPropertyDestination(property, destination, mapping, sourceMapping);\r\n                return property;\r\n            }\r\n\r\n            if (!property.children) {\r\n                property.children = [];\r\n            }\r\n\r\n            // nested call\r\n            return this.getOrCreateProperty({\r\n                propertyNameParts: propertyNameParts.slice(1),\r\n                mapping: mapping,\r\n                propertyArray: property.children,\r\n                parent: property,\r\n                destination: destination,\r\n                sourceMapping: sourceMapping\r\n            });\r\n        }\r\n\r\n        private getPropertyFromArray(name: string, properties: IProperty[]): IProperty {\r\n            if (properties) {\r\n                for (var child of properties) {\r\n                    if (child.name === name) {\r\n                        return child;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private addPropertyDestination(property: IProperty, destination: string, mapping: IMapping, sourceMapping: boolean): void {\r\n            if (!destination) {\r\n                return;\r\n            }\r\n\r\n            let destinationTargetArray: IProperty[] = property.destinations ? property.destinations : [];\r\n            var dstProp = this.getOrCreateProperty({\r\n                propertyNameParts: destination.split('.'),\r\n                mapping: mapping,\r\n                propertyArray: destinationTargetArray,\r\n                sourceMapping: sourceMapping\r\n            });\r\n\r\n            if (destinationTargetArray.length > 0) {\r\n                property.metadata.root.metadata.destinations[destination] = { source: property, destination: dstProp };\r\n                property.metadata.root.metadata.destinationCount++;\r\n                property.destinations = destinationTargetArray;\r\n            }\r\n        }\r\n\r\n        private createProperty(parameters: ICreatePropertyParameters): IProperty {\r\n            var { name, parent, propertyArray, sourceMapping, mapping } = parameters;\r\n\r\n            var property: IProperty = {\r\n                name: name,\r\n                metadata: {\r\n                    mapping: mapping,\r\n                    root: parent ? parent.metadata.root : null,\r\n                    parent: parent,\r\n                    destinations: {},\r\n                    destinationCount: 0\r\n                },\r\n                sourceMapping: sourceMapping,\r\n                level: !parent ? 1 : parent.level + 1,\r\n                ignore: false,\r\n                async: false,\r\n                conversionValuesAndFunctions: []\r\n            };\r\n\r\n            if (property.metadata.root === null) {\r\n                property.metadata.root = property;\r\n            }\r\n\r\n            if (propertyArray) {\r\n                propertyArray.push(property);\r\n            }\r\n\r\n            return property;\r\n        }\r\n\r\n        private createMapForSourceMember(mapping: IMapping, fluentFunc: IFluentFunc, srcProp: string, cnf: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)): IFluentFunc {\r\n            if (typeof cnf !== 'function') {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\r\n            }\r\n\r\n            return this.createMapForMember({\r\n                mapping: mapping,\r\n                fluentFunctions: fluentFunc,\r\n                destinationProperty: srcProp,\r\n                conversionValueOrFunction: cnf,\r\n                sourceMapping: true\r\n            });\r\n        }\r\n\r\n        private createMapForAllMembers(mapping: IMapping, fluentFunc: IFluentFunc, func: (dstObj: any, dstProp: string, val: any) => void): IFluentFunc {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapIgnoreAllNonExisting(mapping: IMapping, fluentFunc: IFluentFunc): IFluentFunc {\r\n            mapping.ignoreAllNonExisting = true;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertToType(mapping: IMapping, fluentFunc: IFluentFunc, typeClass: new () => any): IFluentFunc {\r\n            if (mapping.destinationTypeClass) {\r\n                throw new Error('Destination type class can only be set once.');\r\n            }\r\n\r\n            mapping.destinationTypeClass = typeClass;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertUsing(mapping: IMapping, tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void {\r\n            try {\r\n                // check if sync: TypeConverter instance\r\n                if (tcClassOrFunc instanceof TypeConverter) {\r\n                    this.configureSynchronousConverterFunction(mapping, tcClassOrFunc.convert);\r\n                    return;\r\n                }\r\n\r\n                var functionParameters = AutoMapperHelper.getFunctionParameters(<any>tcClassOrFunc);\r\n                switch (functionParameters.length) {\r\n                    case 0:\r\n                        // check if sync: TypeConverter class definition\r\n                        var typeConverter: TypeConverter;\r\n                        try {\r\n                            typeConverter = (<TypeConverter>new (<new () => TypeConverter>tcClassOrFunc)());\r\n                        } catch (e) {\r\n                            // Obviously, typeConverterClassOrFunction is not a TypeConverter class definition\r\n                        }\r\n                        if (typeConverter instanceof TypeConverter) {\r\n                            this.configureSynchronousConverterFunction(mapping, typeConverter.convert);\r\n                            return;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        // sync: function with resolutionContext parameter\r\n                        this.configureSynchronousConverterFunction(mapping, <(resolutionContext: IResolutionContext) => any>tcClassOrFunc);\r\n                        return;\r\n                    case 2:\r\n                        // check if async: function with resolutionContext and callback parameters\r\n                        this._asyncMapper.createMapConvertUsing(mapping, <(ctx: IResolutionContext, cb: IMapCallback) => void>tcClassOrFunc);\r\n                        return;\r\n                }\r\n\r\n                // okay, just try feeding the function to the configure function anyway...\r\n                this.configureSynchronousConverterFunction(mapping, <any>tcClassOrFunc);\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. ${e}`);\r\n            }\r\n\r\n            throw new Error(`The value provided for typeConverterClassOrFunction is invalid.`);\r\n        }\r\n\r\n        private configureSynchronousConverterFunction(mapping: IMapping, converterFunc: Function): void {\r\n            if (!converterFunc || AutoMapperHelper.getFunctionParameters(converterFunc).length !== 1) {\r\n                throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\r\n            }\r\n\r\n            mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>converterFunc;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any): any => this.mapItemUsingTypeConverter(m, srcObj, dstObj);\r\n        }\r\n\r\n\r\n        private createMapWithProfile(mapping: IMapping, profileName: string): void {\r\n            // check if given profile exists\r\n            var profile = this._profiles[profileName];\r\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\r\n                throw new Error(`Could not find profile with profile name '${profileName}'.`);\r\n            }\r\n\r\n            mapping.profile = profile;\r\n            // merge mappings\r\n            this.createMapWithProfileMergeMappings(mapping, profileName);\r\n        }\r\n\r\n        private createMapWithProfileMergeMappings(mapping: IMapping, profileName: string): void {\r\n            var profileMappingKey = `${profileName}=>${mapping.sourceKey}${profileName}=>${mapping.destinationKey}`;\r\n            var profileMapping: IMapping = this._mappings[profileMappingKey];\r\n            if (!profileMapping) {\r\n                return;\r\n            }\r\n\r\n            // append forAllMemberMappings calls to the original array.\r\n            if (profileMapping.forAllMemberMappings.length > 0) {\r\n                mapping.forAllMemberMappings.push(...profileMapping.forAllMemberMappings);\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.typeConverterFunction) {\r\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.destinationTypeClass) {\r\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\r\n            }\r\n\r\n            // walk through all the profile's property mappings\r\n            for (let property of profileMapping.properties) {\r\n                this.mergeProperty(mapping, mapping.properties, property);\r\n            }\r\n        }\r\n\r\n        private mergeProperty(mapping: IMapping, properties: IProperty[], property: IProperty): void {\r\n            var overwritten = false;\r\n            for (let index = 0; index < mapping.properties.length; index++) {\r\n                let existing = mapping.properties[index];\r\n\r\n                if (existing.name === property.name) {\r\n                    // in which case, we overwrite that one with the profile's property mapping.\r\n                    // okay, maybe a bit rude, but real merging is pretty complex and you should\r\n                    // probably not want to combine normal and profile createMap.forMember calls.\r\n                    mapping.properties[index] = property;\r\n                    overwritten = true;\r\n                }\r\n            }\r\n\r\n            if (overwritten === false) {\r\n                mapping.properties.push(property);\r\n            }\r\n        }\r\n\r\n        private mapInternal(mapping: IMapping, sourceObject: any): any {\r\n            if (mapping.async) {\r\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\r\n            }\r\n\r\n            if (super.isArray(sourceObject)) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass));\r\n        }\r\n\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject);\r\n            });\r\n            return destinationArray;\r\n        }\r\n\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any): void {\r\n            destinationObject = super.handleItem(mapping, sourceObject, destinationObject, (propertyName: string) => {\r\n                this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\r\n            });\r\n            return destinationObject;\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, arrayIndex?: number): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            return (<(ctx: IResolutionContext) => any>mapping.typeConverterFunction)(resolutionContext);\r\n        }\r\n\r\n        private mapProperty(mapping: IMapping, sourceObject: any, destinationObject: any, sourceProperty: string): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject,\r\n                (destinations: IProperty[], valuesAndFunctions: Array<any>, opts: IDMCO) => {\r\n                    var destinationPropertyValue = this.handlePropertyMappings(valuesAndFunctions, opts);\r\n                    for (let destination of destinations) {\r\n                        super.setPropertyValue(mapping, destinationObject, destination, destinationPropertyValue);\r\n                    }\r\n                });\r\n        }\r\n\r\n        private handlePropertyMappings(valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions): any {\r\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\r\n                return opts.intermediatePropertyValue;\r\n            }\r\n\r\n            var valueOrFunction = valuesAndFunctions[0];\r\n            if (typeof valueOrFunction === 'function') {\r\n                var result = valueOrFunction(opts);\r\n\r\n                if (typeof result !== 'undefined') {\r\n                    opts.intermediatePropertyValue = result;\r\n                }\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            } else {\r\n                // valueOrFunction is a value\r\n                opts.intermediatePropertyValue = valueOrFunction;\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            }\r\n        }\r\n\r\n        private createMappingObjectForGivenKeys(srcKeyOrType: string | (new () => any), dstKeyOrType: string | (new () => any)): IMapping {\r\n            var mapping: IMapping = {\r\n                sourceKey: super.getKey(srcKeyOrType),\r\n                destinationKey: super.getKey(dstKeyOrType),\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                properties: [],\r\n                propertiesNew: [],\r\n                typeConverterFunction: undefined,\r\n                mapItemFunction: (m: IMapping, srcObj: any, dstObj: any): any => this.mapItem(m, srcObj, dstObj),\r\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\r\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\r\n                profile: undefined,\r\n                async: false\r\n            };\r\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\r\n            return mapping;\r\n        }\r\n\r\n        private createMapGetFluentApiFunctions(mapping: IMapping): IFluentFunc {\r\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentFunc: IFluentFunc = {\r\n                forMember: (prop: string, valFunc: forMemberValueOrFunction): IFluentFunc => {\r\n                    this.createMapForMemberNewVersion({\r\n                        mapping: mapping,\r\n                        propertyName: prop,\r\n                        transformation: valFunc,\r\n                        sourceMapping: false,\r\n                        fluentFunctions: fluentFunc\r\n                    });\r\n                    return this.createMapForMember({\r\n                        mapping: mapping,\r\n                        fluentFunctions: fluentFunc,\r\n                        destinationProperty: prop,\r\n                        conversionValueOrFunction: valFunc,\r\n                        sourceMapping: false\r\n                    });\r\n                },\r\n                forSourceMember: (prop: string, cfgFunc: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)): IFluentFunc => {\r\n                    this.createMapForMemberNewVersion({\r\n                        mapping: mapping,\r\n                        propertyName: prop,\r\n                        transformation: cfgFunc,\r\n                        sourceMapping: true,\r\n                        fluentFunctions: fluentFunc\r\n                    });\r\n                    return this.createMapForSourceMember(mapping, fluentFunc, prop, cfgFunc);\r\n                },\r\n                forAllMembers: (func: (dstObj: any, dstProp: string, value: any) => void): IFluentFunc =>\r\n                    this.createMapForAllMembers(mapping, fluentFunc, func),\r\n                ignoreAllNonExisting: (): IFluentFunc => this.createMapIgnoreAllNonExisting(mapping, fluentFunc),\r\n                convertToType: (type: new () => any): IFluentFunc => this.createMapConvertToType(mapping, fluentFunc, type),\r\n                convertUsing: (tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void =>\r\n                    this.createMapConvertUsing(mapping, tcClassOrFunc),\r\n                withProfile: (profile: string): void => this.createMapWithProfile(mapping, profile)\r\n            };\r\n\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapForMemberNewVersion(parameters: ICreateMapForMemberParameters): IFluentFunc {\r\n            var { mapping, propertyName, transformation, sourceMapping, fluentFunctions } = parameters;\r\n\r\n            // extract source/destination property names\r\n            var metadata = AutoMapperHelper.getMappingMetadataFromConfigFunction(propertyName, transformation, sourceMapping);\r\n            var { source, destination } = metadata;\r\n\r\n            // create property (regardless of current existance)\r\n            var property = this.createSourceProperty(metadata, null);\r\n\r\n            // merge with existing property or add property\r\n            if (!this.mergeSourceProperty(property, mapping.propertiesNew, sourceMapping)) {\r\n                mapping.propertiesNew.push(property);\r\n            }\r\n\r\n            return fluentFunctions;\r\n        }\r\n\r\n        private createSourceProperty(metadata: IMemberMappingMetaData, parent: ISourceProperty): ISourceProperty {\r\n            var level = !parent ? 0 : parent.level + 1;\r\n            var sourceNameParts = metadata.source.split('.');\r\n\r\n            if (level >= sourceNameParts.length) {\r\n                return null;\r\n            }\r\n\r\n            var source = <ISourceProperty>{\r\n                name: sourceNameParts[level],\r\n                destinationPropertyName: metadata.destination,\r\n                parent: parent,\r\n                level: level,\r\n                children: <ISourceProperty[]>[],\r\n                destination: <IDestinationProperty>null\r\n            };\r\n\r\n            if ((level + 1) < sourceNameParts.length) {\r\n                // recursively add child source properties ...\r\n                var child = this.createSourceProperty(metadata, source);\r\n                if (child) { // TODO should not be necessary, test thoroughly!\r\n                    source.children.push(child);\r\n                }\r\n                source.destination = null;\r\n            } else {\r\n                // ... or (!) add destination\r\n                source.destination = this.createDestinationProperty(metadata, null);\r\n            }\r\n            return source;\r\n        }\r\n\r\n        private createDestinationProperty(metadata: IMemberMappingMetaData, parent: IDestinationProperty): IDestinationProperty {\r\n            var level = !parent ? 0 : parent.level + 1;\r\n            var destinationNameParts = metadata.destination.split('.');\r\n\r\n            if (level >= destinationNameParts.length) {\r\n                return null;\r\n            }\r\n\r\n            var destination = <IDestinationProperty>{\r\n                name: destinationNameParts[level],\r\n                sourcePropertyName: metadata.source,\r\n                parent: parent,\r\n                level: level,\r\n                child: <IDestinationProperty>null,\r\n                transformations: <IDestinationTransformation[]>[],\r\n                ignore: false,\r\n                sourceMapping: false\r\n            };\r\n\r\n            if ((level + 1) < destinationNameParts.length) {\r\n                // recursively add child destination properties\r\n                destination.child = this.createDestinationProperty(metadata, destination);\r\n            } else {\r\n                // add/merge properties\r\n                destination.sourceMapping = metadata.sourceMapping;\r\n                destination.ignore = metadata.ignore;\r\n                destination.transformations.push(metadata.transformation);\r\n            }\r\n\r\n            return destination;\r\n        }\r\n\r\n        private mergeSourceProperty(property: ISourceProperty, existingProperties: ISourceProperty[], sourceMapping: boolean): boolean {\r\n            // find source property\r\n            var existing = sourceMapping\r\n                ? this.findProperty(property.name, existingProperties)\r\n                : this.matchSourcePropertyByDestination(property, existingProperties);\r\n\r\n            if (!existing) {\r\n                return false;\r\n            }\r\n\r\n            if (property.children.length > 0) {\r\n                if (existing.destination) {\r\n                    // a source property registration has one of both: a) children of b) destinations \r\n                    // (rather create duplicate source property entries instead).\r\n                    return false;\r\n                }\r\n\r\n                // merge children ...\r\n                for (let child of property.children) {\r\n                    if (!this.mergeSourceProperty(child, existing.children)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                // ... or (!) merge destinations\r\n                if (property.destination) {\r\n                    // TODO only one destination per source property registration\r\n                    // (rather create duplicate source property entries instead).\r\n                    if (!this.mergeDestinationProperty(property.destination, existing.destination)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        private mergeDestinationProperty(destination: IDestinationProperty, existingDestination: IDestinationProperty): boolean {\r\n            if (!existingDestination) {\r\n                return false; // TODO should never happen, test thoroughly!\r\n            }\r\n\r\n            if (destination.child) {\r\n                if (existingDestination.transformations.length > 0) {\r\n                    // a source property registration has one of both: a) children of b) destinations \r\n                    // (rather create duplicate source property entries instead).\r\n                    return false;\r\n                }\r\n\r\n                // merge children ...\r\n                if (!this.mergeDestinationProperty(destination.child, existingDestination.child)) {\r\n                    return false;\r\n                }\r\n            } else {\r\n                if (existingDestination.sourceMapping !== destination.sourceMapping &&\r\n                    existingDestination.sourcePropertyName !== destination.sourcePropertyName) {\r\n                    return false;\r\n                }\r\n\r\n                // or (!) merge destination properties\r\n                existingDestination.sourceMapping = destination.sourceMapping;\r\n                existingDestination.ignore = destination.ignore;\r\n\r\n                for (let transformation of destination.transformations) {\r\n                    existingDestination.transformations.push(transformation);\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        private matchSourcePropertyByDestination(source: ISourceProperty, properties: ISourceProperty[]): ISourceProperty {\r\n            if (!properties) {\r\n                return null;\r\n            }\r\n\r\n            for (let property of properties) {\r\n                if (property.destinationPropertyName === source.destinationPropertyName) {\r\n                    return property;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private findProperty<TProperty extends IProperty18>(name: string, properties: TProperty[]): TProperty {\r\n            if (!properties) {\r\n                return null;\r\n            }\r\n\r\n            for (var property of properties) {\r\n                if (property.name === name) {\r\n                    return property;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.AutoMapper = ((app: any) => {\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);\r\n"]}