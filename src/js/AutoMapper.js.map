{"version":3,"sources":["AutoMapper.ts"],"names":["AutoMapperJs","AutoMapperJs.AutoMapper","AutoMapperJs.AutoMapper.constructor","AutoMapperJs.AutoMapper.getInstance","AutoMapperJs.AutoMapper.initialize","AutoMapperJs.AutoMapper.createMap","AutoMapperJs.AutoMapper.map","AutoMapperJs.AutoMapper.mapAsync","AutoMapperJs.AutoMapper.assertConfigurationIsValid","AutoMapperJs.AutoMapper.createMapForMember","AutoMapperJs.AutoMapper.createMapForMemberAsync","AutoMapperJs.AutoMapper.createMapForMemberSync","AutoMapperJs.AutoMapper.createMapForMemberHandleMapFrom","AutoMapperJs.AutoMapper.updatePropertyName","AutoMapperJs.AutoMapper.createMapForMemberHandleIgnore","AutoMapperJs.AutoMapper.getPropertyByDestinationProperty","AutoMapperJs.AutoMapper.getOrCreateProperty","AutoMapperJs.AutoMapper.createProperty","AutoMapperJs.AutoMapper.createMapForSourceMember","AutoMapperJs.AutoMapper.createMapForAllMembers","AutoMapperJs.AutoMapper.createMapIgnoreAllNonExisting","AutoMapperJs.AutoMapper.createMapConvertToType","AutoMapperJs.AutoMapper.createMapConvertUsing","AutoMapperJs.AutoMapper.configureSynchronousConverterFunction","AutoMapperJs.AutoMapper.createMapWithProfile","AutoMapperJs.AutoMapper.createMapWithProfileMergeMappings","AutoMapperJs.AutoMapper.mergeProperty","AutoMapperJs.AutoMapper.mapInternal","AutoMapperJs.AutoMapper.mapArray","AutoMapperJs.AutoMapper.mapItem","AutoMapperJs.AutoMapper.mapItemUsingTypeConverter","AutoMapperJs.AutoMapper.mapProperty","AutoMapperJs.AutoMapper.handlePropertyMappings","AutoMapperJs.AutoMapper.createMappingObjectForGivenKeys","AutoMapperJs.AutoMapper.createMapGetFluentApiFunctions"],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapperBase.ts\" />\r\n/// <reference path=\"AsyncAutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    // interface shorthands\r\n    type IFluentFunc = ICreateMapFluentFunctions;\r\n    type IDMCO = IMemberConfigurationOptions;\r\n    type ISMCO = ISourceMemberConfigurationOptions;\r\n    type IMC = IMemberCallback;\r\n    type IRC = IResolutionContext;\r\n    type TC = TypeConverter;\r\n\r\n    // method overload shorthands\r\n    type stringOrClass = string | (new() => any);\r\n    type forMemberValueOrFunction = any | ((opts: IDMCO) => any) | ((opts: IDMCO, cb: IMC) => void);\r\n    type convertUsingClassOrInstanceOrFunction = ((ctx: IRC) => any) | ((ctx: IRC, callback: IMapCallback) => void) | TC | (new() => TC);\r\n\r\n    export class AutoMapper extends AutoMapperBase {\r\n        private static _instance = new AutoMapper();\r\n\r\n        private _profiles: { [name: string]: IProfile };\r\n        private _mappings: { [key: string]: IMapping };\r\n\r\n        private _asyncMapper: AsyncAutoMapper;\r\n\r\n        /**\r\n         * This class is intended to be a Singleton. Preferrably use getInstance() \r\n         * function instead of using the constructor directly from code.\r\n         */\r\n        constructor() {\r\n            super();\r\n\r\n            if (AutoMapper._instance) {\r\n                return AutoMapper._instance;\r\n            } else {\r\n                AutoMapper._instance = this;\r\n\r\n                this._profiles = {};\r\n                this._mappings = {};\r\n\r\n                this._asyncMapper = new AsyncAutoMapper();\r\n            }\r\n        }\r\n\r\n        public static getInstance(): AutoMapper {\r\n            return AutoMapper._instance;\r\n        }\r\n\r\n        /**\r\n         * Initializes the mapper with the supplied configuration.\r\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\r\n         */\r\n        public initialize(configFunction: (config: IConfiguration) => void): void {\r\n            var that = this;\r\n\r\n            var configuration: IConfiguration = <any>{\r\n                addProfile: (profile: IProfile) : void => {\r\n                    profile.configure();\r\n                    that._profiles[profile.profileName] = profile;\r\n                },\r\n                createMap: function (sourceKey: string, destinationKey: string): IFluentFunc {\r\n                    // pass through using arguments to keep createMap's currying support fully functional.\r\n                    return that.createMap.apply(that, arguments);\r\n                }\r\n            };\r\n\r\n            configFunction(configuration);\r\n        }\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.ICreateMapFluentFunctions}\r\n         */\r\n        public createMap(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any)): IFluentFunc {\r\n            // provide currying support.\r\n            if (arguments.length < 2) {\r\n                return AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\r\n\r\n            return this.createMapGetFluentApiFunctions(mapping);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKeyOrType: stringOrClass, destinationKeyOrType: stringOrClass, sourceObject: any): any {\r\n            if (arguments.length === 3) {\r\n                return this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\r\n            }\r\n\r\n            // provide performance optimized (preloading) currying support.\r\n            if (arguments.length === 2) {\r\n                return (srcObj: any) => this.mapInternal(super.getMapping(this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj);\r\n            }\r\n\r\n            if (arguments.length === 1) {\r\n                return (dstKey: string | (new() => any), srcObj: any) => this.map(sourceKeyOrType, dstKey, srcObj);\r\n            }\r\n\r\n            return (srcKey: string | (new() => any), dstKey: string | (new() => any), srcObj: any) => this.map(srcKey, dstKey, srcObj);\r\n        }\r\n\r\n        /**\r\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\r\n         */\r\n        public mapAsync(sourceKeyOrType: string | (new() => any), destinationKeyOrType: string | (new() => any), sourceObject: any, callback: IMapCallback): any {\r\n            return this._asyncMapper.map(sourceKeyOrType, destinationKeyOrType, this._mappings, sourceObject, callback);\r\n        }\r\n\r\n        /**\r\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\r\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\r\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable. \r\n         */\r\n        public assertConfigurationIsValid(strictMode: boolean = true): void {\r\n            AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\r\n        }\r\n\r\n        private createMapForMember(parameters: ICreateMapParameters): IFluentFunc {\r\n            var { mapping, destinationProperty, conversionValueOrFunction, sourceMapping, fluentFunctions } = parameters;\r\n\r\n            var metadata = AutoMapperHelper.getMappingMetadataFromConfigFunction(destinationProperty, conversionValueOrFunction, sourceMapping);\r\n\r\n            var property: IProperty;\r\n            if (!sourceMapping) {\r\n                property = this.getPropertyByDestinationProperty(mapping.properties, destinationProperty);\r\n                if (!property) {\r\n                    property = this.getOrCreateProperty({\r\n                        propertyNameParts: metadata.source.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: mapping.properties,\r\n                        parent: null,\r\n                        destination: destinationProperty,\r\n                        sourceMapping: sourceMapping\r\n                    });\r\n                }\r\n            } else {\r\n                property = this.getOrCreateProperty({\r\n                    propertyNameParts: metadata.source.split('.'),\r\n                    mapping: mapping,\r\n                    propertyArray: mapping.properties,\r\n                    parent: null,\r\n                    destination: destinationProperty,\r\n                    sourceMapping: sourceMapping\r\n                });\r\n            }\r\n\r\n            if (metadata.async) {\r\n                this.createMapForMemberAsync(property, conversionValueOrFunction, metadata);\r\n            } else {\r\n                this.createMapForMemberSync(property, conversionValueOrFunction, metadata);\r\n            }\r\n\r\n            return fluentFunctions;\r\n        }\r\n\r\n        private createMapForMemberAsync(property: IProperty, valueOrFunction: any, metadata: IMemberMappingMetaData): void {\r\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\r\n                return;\r\n            }\r\n\r\n            this._asyncMapper.createMapForMember(property, <(opts: IDMCO, cb: IMemberCallback) => void>valueOrFunction, metadata);\r\n        }\r\n\r\n        private createMapForMemberSync(property: IProperty, valueOrFunction: any, metadata: IMemberMappingMetaData): void {\r\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\r\n                return;\r\n            }\r\n\r\n            this.createMapForMemberHandleMapFrom(property, metadata);\r\n            property.conditionFunction = metadata.condition;\r\n            property.conversionValuesAndFunctions.push(valueOrFunction);\r\n        }\r\n\r\n        private createMapForMemberHandleMapFrom(property: IProperty, metadata: IMemberMappingMetaData): void {\r\n            if (metadata.source === metadata.destination) {\r\n                return;\r\n            }\r\n\r\n            var { mapping, root } = property.metadata;\r\n\r\n            var sourceNameParts = metadata.source.split('.');\r\n            if (sourceNameParts.length === property.level) {\r\n                this.updatePropertyName(sourceNameParts, property);\r\n            } else {\r\n                // check if only one destination on property root. in that case, rebase property and overwrite root.\r\n                if (root.metadata.destinationCount === 1) {\r\n                    var propertyRootIndex = mapping.properties.indexOf(root);\r\n                    mapping.properties[propertyRootIndex] = undefined;\r\n                    var propArray: IProperty[] = [];\r\n                    var newProperty = this.getOrCreateProperty({\r\n                        propertyNameParts: metadata.source.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: propArray,\r\n                        parent: null,\r\n                        destination: metadata.destination,\r\n                        sourceMapping: metadata.sourceMapping\r\n                    });\r\n                    newProperty.conditionFunction = property.conditionFunction;\r\n                    newProperty.conversionValuesAndFunctions = property.conversionValuesAndFunctions;\r\n                    mapping.properties[propertyRootIndex] = propArray[0];\r\n                } else {\r\n                    throw new Error('Rebasing properties with multiple destinations is not yet implemented.');\r\n                }\r\n            }\r\n        }\r\n\r\n        private updatePropertyName(sourceNameParts: string[], property: IProperty): void {\r\n            property.name = sourceNameParts[sourceNameParts.length - 1];\r\n            if (sourceNameParts.length === 1) {\r\n                return;\r\n            }\r\n\r\n            this.updatePropertyName(sourceNameParts.splice(0, 1), property.metadata.parent);\r\n        }\r\n\r\n        private createMapForMemberHandleIgnore(property: IProperty, metadata: IMemberMappingMetaData): boolean {\r\n            if (property.ignore || metadata.ignore) {\r\n                // source name will always be destination name when ignoring.\r\n                property.name = metadata.destination;\r\n                property.ignore = true;\r\n                property.async = false;\r\n                property.destinations = null;\r\n                property.conversionValuesAndFunctions = [];\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private getPropertyByDestinationProperty(properties: IProperty[], destinationPropertyName: string): IProperty {\r\n            if (properties === null || properties === undefined) {\r\n                return null;\r\n            }\r\n\r\n            for (let srcProp of properties) {\r\n                if (srcProp.metadata.destinations !== null && srcProp.metadata.destinations !== undefined) {\r\n                    for (let destination in srcProp.metadata.destinations) {\r\n                        if (destination === destinationPropertyName) {\r\n                            return srcProp.metadata.destinations[destination].source;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let childProp = this.getPropertyByDestinationProperty(srcProp.children, destinationPropertyName);\r\n                if (childProp != null) {\r\n                    return childProp;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private getOrCreateProperty(parameters: IGetOrCreatePropertyParameters): IProperty {\r\n            var { propertyNameParts, mapping, parent, propertyArray, destination, sourceMapping } = parameters;\r\n\r\n            var name = propertyNameParts[0];\r\n\r\n            var property: IProperty;\r\n            if (propertyArray) {\r\n                for (var child of propertyArray) {\r\n                    if (child.name === name) {\r\n                        property = child;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (property === undefined || property === null) {\r\n                property = this.createProperty({\r\n                    name: name,\r\n                    parent: parent,\r\n                    propertyArray: propertyArray,\r\n                    sourceMapping: sourceMapping,\r\n                    mapping: mapping\r\n                });\r\n            }\r\n\r\n            if (propertyNameParts.length === 1) {\r\n                if (destination) {\r\n                    let destinationTargetArray: IProperty[] = property.destinations ? property.destinations : [];\r\n                    var dstProp = this.getOrCreateProperty({\r\n                        propertyNameParts: destination.split('.'),\r\n                        mapping: mapping,\r\n                        propertyArray: destinationTargetArray,\r\n                        parent: null,\r\n                        destination: null,\r\n                        sourceMapping: sourceMapping\r\n                    });\r\n                    if (destinationTargetArray.length > 0) {\r\n                        property.metadata.root.metadata.destinations[destination] = { source: property, destination: dstProp };\r\n                        property.metadata.root.metadata.destinationCount++;\r\n                        property.destinations = destinationTargetArray;\r\n                    }\r\n                }\r\n                return property;\r\n            }\r\n\r\n            if (property.children === null || property.children === undefined) {\r\n               property.children = [];\r\n            }\r\n\r\n            return this.getOrCreateProperty({\r\n                propertyNameParts: propertyNameParts.slice(1),\r\n                mapping: mapping,\r\n                propertyArray: property.children,\r\n                parent: property,\r\n                destination: destination,\r\n                sourceMapping: sourceMapping\r\n            });\r\n        }\r\n\r\n        private createProperty(parameters: ICreatePropertyParameters): IProperty {\r\n            var { name, parent, propertyArray, sourceMapping, mapping } = parameters;\r\n\r\n            var property: IProperty = {\r\n                name: name,\r\n                metadata: {\r\n                    mapping: mapping,\r\n                    root: parent ? parent.metadata.root : null,\r\n                    parent: parent,\r\n                    destinations: {},\r\n                    destinationCount: 0\r\n                },\r\n                sourceMapping: sourceMapping,\r\n                level: !parent ? 1 : parent.level + 1,\r\n                ignore: false,\r\n                async: false,\r\n                conversionValuesAndFunctions: []\r\n            };\r\n\r\n            if (property.metadata.root === null) {\r\n                property.metadata.root = property;\r\n            }\r\n\r\n            if (propertyArray) {\r\n                propertyArray.push(property);\r\n            }\r\n\r\n            return property;\r\n        }\r\n\r\n        private createMapForSourceMember(mapping: IMapping, fluentFunc: IFluentFunc, srcProp: string, cnf: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)): IFluentFunc {\r\n            if (typeof cnf !== 'function') {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\r\n            }\r\n\r\n            return this.createMapForMember({\r\n                mapping: mapping,\r\n                fluentFunctions: fluentFunc,\r\n                destinationProperty: srcProp,\r\n                conversionValueOrFunction: cnf,\r\n                sourceMapping: true\r\n            });\r\n        }\r\n\r\n        private createMapForAllMembers(mapping: IMapping, fluentFunc: IFluentFunc, func: (dstObj: any, dstProp: string, val: any) => void): IFluentFunc {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapIgnoreAllNonExisting(mapping: IMapping, fluentFunc: IFluentFunc): IFluentFunc {\r\n            mapping.ignoreAllNonExisting = true;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertToType(mapping: IMapping, fluentFunc: IFluentFunc, typeClass: new () => any): IFluentFunc {\r\n            if (mapping.destinationTypeClass) {\r\n                if (mapping.destinationTypeClass === typeClass) {\r\n                    return fluentFunc;\r\n                }\r\n\r\n                throw new Error('Destination type class can only be set once.');\r\n            }\r\n\r\n            mapping.destinationTypeClass = typeClass;\r\n            return fluentFunc;\r\n        }\r\n\r\n        private createMapConvertUsing(mapping: IMapping, tcClassOrFunc: convertUsingClassOrInstanceOrFunction): void {\r\n            try {\r\n                // check if sync: TypeConverter instance\r\n                if (tcClassOrFunc instanceof TypeConverter) {\r\n                    this.configureSynchronousConverterFunction(mapping, tcClassOrFunc.convert);\r\n                    return;\r\n                }\r\n\r\n                // check if sync: TypeConverter class definition\r\n                var typeConverter: TypeConverter;\r\n                try {\r\n                    typeConverter = (<TypeConverter>new (<new() => TypeConverter>tcClassOrFunc)());\r\n                } catch (e) {\r\n                    // Obviously, typeConverterClassOrFunction is not a TypeConverter class definition\r\n                }\r\n                if (typeConverter instanceof TypeConverter) {\r\n                    this.configureSynchronousConverterFunction(mapping, typeConverter.convert);\r\n                    return;\r\n                }\r\n\r\n                var functionParameters = AutoMapperHelper.getFunctionParameters(<any>tcClassOrFunc);\r\n\r\n                // check if sync: function with resolutionContext parameter\r\n                if (functionParameters.length === 1) {\r\n                    this.configureSynchronousConverterFunction(mapping, <(resolutionContext: IResolutionContext) => any>tcClassOrFunc);\r\n                    return;\r\n                }\r\n\r\n                // check if async: function with resolutionContext and callback parameters\r\n                if (functionParameters.length === 2) {\r\n                    this._asyncMapper.createMapConvertUsing(mapping, <(ctx: IResolutionContext, cb: IMapCallback) => void>tcClassOrFunc);\r\n                    return;\r\n                }\r\n\r\n                // okay, just try feeding the function to the configure function anyway...\r\n                this.configureSynchronousConverterFunction(mapping, <any>tcClassOrFunc);\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. ${e}`);\r\n            }\r\n\r\n            throw new Error(`The value provided for typeConverterClassOrFunction is invalid.`);\r\n        }\r\n\r\n        private configureSynchronousConverterFunction(mapping: IMapping, converterFunc: Function): void {\r\n            if (!converterFunc || AutoMapperHelper.getFunctionParameters(converterFunc).length !== 1) {\r\n                throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\r\n            }\r\n\r\n            mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>converterFunc;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any): any => this.mapItemUsingTypeConverter(m, srcObj, dstObj);\r\n        }\r\n\r\n\r\n        private createMapWithProfile(mapping: IMapping, profileName: string): void {\r\n            // check if given profile exists\r\n            var profile = this._profiles[profileName];\r\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\r\n                throw new Error(`Could not find profile with profile name '${profileName}'.`);\r\n            }\r\n\r\n            mapping.profile = profile;\r\n            // merge mappings\r\n            this.createMapWithProfileMergeMappings(mapping, profileName);\r\n        }\r\n\r\n        private createMapWithProfileMergeMappings(mapping: IMapping, profileName: string): void {\r\n            var profileMappingKey = `${profileName}=>${mapping.sourceKey}${profileName}=>${mapping.destinationKey}`;\r\n            var profileMapping: IMapping = this._mappings[profileMappingKey];\r\n            if (!profileMapping) {\r\n                return;\r\n            }\r\n\r\n            // append forAllMemberMappings calls to the original array.\r\n            if (profileMapping.forAllMemberMappings.length > 0) {\r\n                mapping.forAllMemberMappings.push(...profileMapping.forAllMemberMappings);\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.typeConverterFunction) {\r\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\r\n            }\r\n\r\n            // overwrite original type converter function\r\n            if (profileMapping.destinationTypeClass) {\r\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\r\n            }\r\n\r\n            // walk through all the profile's property mappings\r\n            for (let property of profileMapping.properties) {\r\n                this.mergeProperty(mapping, mapping.properties, property);\r\n            }\r\n        }\r\n\r\n        private mergeProperty(mapping: IMapping, properties: IProperty[], property: IProperty): void {\r\n            for (let index = 0; index < mapping.properties.length; index++) {\r\n                let existing = mapping.properties[index];\r\n\r\n                if (existing.name === property.name) {\r\n                    // in which case, we overwrite that one with the profile's property mapping.\r\n                    // okay, maybe a bit rude, but real merging is pretty complex and you should\r\n                    // probably not want to combine normal and profile createMap.forMember calls.\r\n                    mapping.properties[index] = property;\r\n                }\r\n            }\r\n        }\r\n\r\n        private mapInternal(mapping: IMapping, sourceObject: any): any {\r\n            if (mapping.async) {\r\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\r\n            }\r\n\r\n            if (super.isArray(sourceObject)) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass));\r\n        }\r\n\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                (<IMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject);\r\n            });\r\n            return destinationArray;\r\n        }\r\n\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any): void {\r\n            super.handleItem(mapping, sourceObject, destinationObject, (propertyName: string) => {\r\n                this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\r\n            });\r\n            return destinationObject;\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, arrayIndex?: number): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            return (<(ctx: IResolutionContext) => any>mapping.typeConverterFunction)(resolutionContext);\r\n        }\r\n\r\n        private mapProperty(mapping: IMapping, sourceObject: any, destinationObject: any, sourceProperty: string): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject,\r\n                (destinations: IProperty[], valuesAndFunctions: Array<any>, opts: IDMCO) => {\r\n                    var destinationPropertyValue = this.handlePropertyMappings(valuesAndFunctions, opts);\r\n                    for (let destination of destinations) {\r\n                        super.setPropertyValue(mapping, destinationObject, destination, destinationPropertyValue);\r\n                    }\r\n                });\r\n        }\r\n\r\n        private handlePropertyMappings(valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions): any {\r\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\r\n                return opts.intermediatePropertyValue;\r\n            }\r\n\r\n            var valueOrFunction = valuesAndFunctions[0];\r\n            if (typeof valueOrFunction === 'function') {\r\n                var result = valueOrFunction(opts);\r\n\r\n                if (typeof result !== 'undefined') {\r\n                    opts.intermediatePropertyValue = result;\r\n                }\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            } else {\r\n                // valueOrFunction is a value\r\n                opts.intermediatePropertyValue = valueOrFunction;\r\n\r\n                // recursively walk values/functions\r\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\r\n            }\r\n        }\r\n\r\n        private createMappingObjectForGivenKeys(srcKeyOrType: string | (new() => any), dstKeyOrType: string | (new() => any)): IMapping {\r\n            var mapping: IMapping = {\r\n                sourceKey: super.getKey(srcKeyOrType),\r\n                destinationKey: super.getKey(dstKeyOrType),\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                properties: [],\r\n                typeConverterFunction: undefined,\r\n                mapItemFunction: (m: IMapping, srcObj: any, dstObj: any): any => this.mapItem(m, srcObj, dstObj),\r\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\r\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\r\n                profile: undefined,\r\n                async: false\r\n            };\r\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\r\n            return mapping;\r\n        }\r\n\r\n        private createMapGetFluentApiFunctions(mapping: IMapping): IFluentFunc {\r\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentFunc: IFluentFunc = {\r\n                forMember: (prop: string, valFunc: forMemberValueOrFunction) : IFluentFunc =>\r\n                    this.createMapForMember({\r\n                        mapping: mapping,\r\n                        fluentFunctions: fluentFunc,\r\n                        destinationProperty: prop,\r\n                        conversionValueOrFunction: valFunc,\r\n                        sourceMapping: false\r\n                    }),\r\n                forSourceMember: (prop: string, cfgFunc: ((opts: ISMCO) => any) | ((opts: ISMCO, cb: IMC) => void)) : IFluentFunc =>\r\n                    this.createMapForSourceMember(mapping, fluentFunc, prop, cfgFunc),\r\n                forAllMembers: (func: (dstObj: any, dstProp: string, value: any) => void) : IFluentFunc =>\r\n                    this.createMapForAllMembers(mapping, fluentFunc, func),\r\n                ignoreAllNonExisting: () : IFluentFunc => this.createMapIgnoreAllNonExisting(mapping, fluentFunc),\r\n                convertToType: (type: new () => any) : IFluentFunc => this.createMapConvertToType(mapping, fluentFunc, type),\r\n                convertUsing: (tcClassOrFunc: convertUsingClassOrInstanceOrFunction) : void =>\r\n                    this.createMapConvertUsing(mapping, tcClassOrFunc),\r\n                withProfile: (profile: string) : void => this.createMapWithProfile(mapping, profile)\r\n            };\r\n\r\n            return fluentFunc;\r\n        }\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.AutoMapper = ((app: any) => {\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);"],"sourceRoot":"/source/"}