{"version":3,"sources":["AsyncAutoMapper.ts"],"names":["AutoMapperJs","AutoMapperJs.AsyncAutoMapper","AutoMapperJs.AsyncAutoMapper.constructor","AutoMapperJs.AsyncAutoMapper.createMapForMember","AutoMapperJs.AsyncAutoMapper.createMapConvertUsing","AutoMapperJs.AsyncAutoMapper.map","AutoMapperJs.AsyncAutoMapper.mapWithMapping","AutoMapperJs.AsyncAutoMapper.mapArray","AutoMapperJs.AsyncAutoMapper.mapItemUsingTypeConverter","AutoMapperJs.AsyncAutoMapper.mapItem","AutoMapperJs.AsyncAutoMapper.mapProperty","AutoMapperJs.AsyncAutoMapper.handlePropertyMappings","AutoMapperJs.AsyncAutoMapper.handlePropertyMappingFunction"],"mappings":"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","file":"AsyncAutoMapper.js","sourcesContent":["/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\r\n/// <reference path=\"AutoMapper.ts\" />\r\n/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"AutoMapperHelper.ts\" />\r\n/// <reference path=\"AutoMapperValidator.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    /**\r\n     * AsyncAutoMapper implementation, for asynchronous mapping support when using AutoMapper.\r\n     */\r\n    export class AsyncAutoMapper extends AutoMapperBase {\r\n        private static asyncInstance = new AsyncAutoMapper();\r\n\r\n        constructor() {\r\n            super();\r\n            AsyncAutoMapper.asyncInstance = this;\r\n        }\r\n\r\n        public createMapForMember(property: IProperty,\r\n                                  func: ((opts: IMemberConfigurationOptions, cb: IMemberCallback) => void),\r\n                                  metadata: IMemberMappingMetaData): void {\r\n            var { mapping } = property.metadata;\r\n\r\n            mapping.async = true;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any, cb: IMapCallback) => this.mapItem(m, srcObj, dstObj, cb);\r\n            property.async = true;\r\n            property.conversionValuesAndFunctions.push(func);\r\n        }\r\n\r\n        public createMapConvertUsing(mapping: IMapping, converterFunction: (ctx: IResolutionContext, cb: IMapCallback) => void): void {\r\n            mapping.async = true;\r\n            mapping.typeConverterFunction = converterFunction;\r\n            mapping.mapItemFunction = (m: IMapping, srcObj: any, dstObj: any, cb: IMapCallback) => this.mapItemUsingTypeConverter(m, srcObj, dstObj, cb);\r\n        }\r\n\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any)): (dstKey: string | (new () => any), srcObj: any, cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey: string | (new () => any)): (srcObj: any, cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey?: string | (new () => any), sourceObject?: any): (cb: IMapCallback) => void;\r\n        public map(m: { [key: string]: IMapping }, srcKey: string | (new () => any), dstKey?: string | (new () => any), sourceObject?: any, cb?: IMapCallback): void;\r\n        public map(\r\n            mappings: { [key: string]: IMapping }, sourceKey: string | (new () => any), destinationKey?: string | (new () => any), sourceObject?: any, callback?: IMapCallback\r\n        ): any /* actually, void (impossible with overloads) */ {\r\n\r\n            switch (arguments.length) {\r\n                case 5:\r\n                    this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), sourceObject, callback);\r\n                    return;\r\n                // provide performance optimized (preloading) currying support.\r\n                case 4:\r\n                    return (cb: IMapCallback) => this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), sourceObject, cb);\r\n                case 3:\r\n                    return (srcObj: any, cb: IMapCallback) => this.mapWithMapping(super.getMapping(mappings, sourceKey, destinationKey), srcObj, cb);\r\n                case 2:\r\n                    return (dstKey: string | (new () => any), srcObj: any, cb: IMapCallback) => this.map(mappings, sourceKey, dstKey, srcObj, cb);\r\n                default:\r\n                    throw new Error('The AsyncAutoMapper.map function expects between 2 and 5 parameters, you provided ' + arguments.length + '.');\r\n            }\r\n        }\r\n\r\n        public mapWithMapping(mapping: IMapping, sourceObject: any, callback: IMapCallback): void {\r\n            if (super.isArray(sourceObject)) {\r\n                this.mapArray(mapping, sourceObject, callback);\r\n                return;\r\n            }\r\n\r\n            return (<IAsyncMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, super.createDestinationObject(mapping.destinationTypeClass), callback);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceArray The source array to map.\r\n         * @returns {Array<any>} Destination array.\r\n         */\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>, callback: IMapCallback): void {\r\n            var callbacksToGo = 0;\r\n\r\n            var destinationArray = super.handleArray(mapping, sourceArray, (sourceObject: any, destinationObject: any) => {\r\n                callbacksToGo++;\r\n                (<IAsyncMapItemFunction>mapping.mapItemFunction)(mapping, sourceObject, destinationObject, (result: any): void => {\r\n                    callbacksToGo--;\r\n                });\r\n            });\r\n\r\n            var waitForCallbackToSend = (): void => {\r\n                if (callbacksToGo === 0) {\r\n                    callback(destinationArray);\r\n                } else {\r\n                    setTimeout((): void => {\r\n                        waitForCallbackToSend();\r\n                    }, 10 * callbacksToGo);\r\n                }\r\n            };\r\n\r\n            waitForCallbackToSend();\r\n        }\r\n\r\n        private mapItemUsingTypeConverter(mapping: IMapping, sourceObject: any, destinationObject: any, callback: IMapCallback): void {\r\n            var resolutionContext: IResolutionContext = {\r\n                sourceValue: sourceObject,\r\n                destinationValue: destinationObject\r\n            };\r\n            (<(ctx: IResolutionContext, cb: IMapCallback) => any>mapping.typeConverterFunction)(resolutionContext, callback);\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param callback The callback to call after async mapping has been executed.\r\n         */\r\n        private mapItem(mapping: IMapping, sourceObject: any, destinationObject: any, callback: IMapCallback): void {\r\n            var callbacksToGo = 0;\r\n\r\n            super.handleItem(mapping, sourceObject, destinationObject, (sourceProperty: string) => {\r\n                callbacksToGo++;\r\n                this.mapProperty(mapping, sourceObject, sourceProperty, destinationObject, (result: any): void => {\r\n                    callbacksToGo--;\r\n                });\r\n            });\r\n\r\n            var waitForCallbackToSend = (): void => {\r\n                if (callbacksToGo === 0) {\r\n                    callback(destinationObject);\r\n                } else {\r\n                    setTimeout((): void => {\r\n                        waitForCallbackToSend();\r\n                    }, 10 * callbacksToGo);\r\n                }\r\n            };\r\n\r\n            waitForCallbackToSend();\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param sourcePropertyName The source property to map.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param callback The callback to call after async property mapping has been executed.\r\n         */\r\n        private mapProperty(mapping: IMapping, sourceObject: any, sourceProperty: string, destinationObject: any, callback: IMemberCallback): void {\r\n            super.handleProperty(mapping, sourceObject, sourceProperty, destinationObject,\r\n                (destinations: IProperty[], valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions) => {\r\n                    this.handlePropertyMappings(valuesAndFunctions, opts, (destinationPropertyValue: any) => {\r\n                        for (let destination of destinations) {\r\n                            super.setPropertyValue(mapping, destinationObject, destination, destinationPropertyValue);\r\n                        }\r\n                        callback(destinationPropertyValue);\r\n                    });\r\n                }, (destinationPropertyValue: any) => {\r\n                    callback(destinationPropertyValue);\r\n                });\r\n        }\r\n\r\n        private handlePropertyMappings(valuesAndFunctions: Array<any>, opts: IMemberConfigurationOptions, callback: IMemberCallback): void {\r\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\r\n                callback(opts.intermediatePropertyValue);\r\n                return;\r\n            }\r\n\r\n            var valueOrFunction = valuesAndFunctions[0];\r\n\r\n            if (typeof valueOrFunction === 'function') {\r\n                this.handlePropertyMappingFunction(valueOrFunction, opts, (result: any) => {\r\n                    if (typeof result !== 'undefined') {\r\n                        opts.intermediatePropertyValue = result;\r\n\r\n                        // recursively walk values/functions\r\n                        this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\r\n                    }\r\n                });\r\n            } else {\r\n                // valueOrFunction is a value\r\n                opts.intermediatePropertyValue = valueOrFunction;\r\n\r\n                // recursively walk values/functions\r\n                this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\r\n            }\r\n        }\r\n\r\n        private handlePropertyMappingFunction(func: Function, opts: IMemberConfigurationOptions, callback: IMemberCallback): void {\r\n            // check if function is asynchronous\r\n            var args = AutoMapperHelper.getFunctionParameters(func);\r\n            if (args.length === 2) { // asynchronous: opts, callback\r\n                func(opts, callback);\r\n                return;\r\n            }\r\n\r\n            callback(func(opts));\r\n        }\r\n    }\r\n}"],"sourceRoot":"/source/"}