{"version":3,"sources":["AutoMapperHelper.js","AutoMapperValidator.js","AutoMapperEnumerations.js","AutoMapperBase.js","AsyncAutoMapper.js","AutoMapper.js","Profile.js","TypeConverter.js","naming-conventions/CamelCaseNamingConvention.js","naming-conventions/PascalCaseNamingConvention.js"],"names":["AutoMapperJs","AutoMapperHelper","getClassName","classType","name","constructor","className","toString","matchParts","match","length","str","charAt","arr","Error","getFunctionParameters","functionStr","stripComments","argumentNames","functionString","replace","functionParameterNames","slice","indexOf","Array","handleCurrying","func","args","closure","accumulator","moreArgs","alreadyProvidedArgs","stillToCome","previousAlreadyProvidedArgs","previousStillToCome","i","functionCallResult","apply","arguments","argumentsStillToCome","argumentsCopy","prototype","getMappingMetadataFromTransformationFunction","destination","sourceMapping","source","transformation","getDestinationTransformation","condition","ignore","async","parameterNames","optsParamName","getMapFromString","metadata","getIgnoreFromString","getFunctionCallIndex","getConditionFromFunction","isFunction","transformationType","DestinationTransformationType","Constant","constant","AsyncSourceMemberOptions","asyncSourceMemberConfigurationOptionsFunc","SourceMemberOptions","sourceMemberConfigurationOptionsFunc","AsyncMemberOptions","asyncMemberConfigurationOptionsFunc","MemberOptions","memberConfigurationOptionsFunc","optionsParameterName","indexOfIgnore","indexOfMapFromStart","indexOfMapFromEnd","ignoreString","substring","trim","defaultValue","indexOfMapFrom","mapFromString","functionToLookFor","indexOfFunctionCall","sourceProperty","sourceObject","configFuncOptions","predicate","mapFrom","sourcePropertyName","intermediatePropertyValue","exc","AutoMapperValidator","assertConfigurationIsValid","mappings","strictMode","key","hasOwnProperty","assertMappingConfiguration","mapping","mappingKey","sourceKey","destinationKey","sourceType","sourceTypeClass","destinationType","destinationTypeClass","sourceClassName","undefined","destinationClassName","tryHandle","errorMessage","validatedMembers","srcObj","dstObj","_i","_a","properties","property","validatePropertyMapping","push","srcMember","validateProperty","dstMember","propertyMapping","member","validateSourcePropertyMapping","validateDestinationPropertyMapping","AutoMapperBase","getMapping","srcKey","this","getKey","dstKey","keyStringOrType","isArray","handleArray","sourceArray","itemFunc","arrayLength","destinationArray","index","destinationObject","createDestinationObject","handleItem","propertyFunction","sourceProperties","atLeastOnePropertyMapped","handleProperty","loopMemberValuesAndFunctions","autoMappingCallbackFunction","getMappingProperty","handlePropertyWithPropertyMapping","handlePropertyWithAutoMapping","setPropertyValue","destinationProperty","destinationPropertyValue","forAllMemberMappings","forAllMemberMapping","handleNestedForAllMemberMappings","setNestedPropertyValue","setPropertyValueByName","children","setChildPropertyValues","isSuccess","destinationAlreadyExists","count","tmpObj","child","isChildSucces","child_1","properties_1","ignoreAllNonExisting","Object","keys","objectValue","isNestedObject","createMap","convertToType","map","destinationPropertyName","getDestinationPropertyName","profile","getDestinationPropertyValue","conditionFunction","destinations","conversionValuesAndFunctions","childSourceObject","memberConfigurationOptions","sourcePropertyNameParts","split","sourceMemberNamingConvention","splittingExpression","splice","destinationMemberNamingConvention","transformPropertyName","error","__extends","d","b","__","p","create","AsyncAutoMapper","_super","call","asyncInstance","sourceKeyOrType","destinationKeyOrType","createMapForMember","_this","mapItemFunction","m","cb","mapItem","createMapConvertUsing","converterFunction","typeConverterFunction","mapItemUsingTypeConverter","callback","mapWithMapping","mapArray","callbacksToGo","result","waitForCallbackToSend","setTimeout","resolutionContext","sourceValue","destinationValue","mapProperty","valuesAndFunctions","opts","handlePropertyMappings","destinations_1","valueOrFunction","handlePropertyMappingFunction","AutoMapper","_instance","_profiles","_mappings","_asyncMapper","getInstance","initialize","configFunction","that","configuration","addProfile","configure","profileName","createMappingObjectForGivenKeys","createMapGetFluentApiFunctions","mapInternal","mapAsync","parameters","conversionValueOrFunction","fluentFunctions","getPropertyByDestinationProperty","getOrCreateProperty","propertyNameParts","propertyArray","parent","createMapForMemberHandleIgnore","createMapForMemberHandleMapFrom","root","sourceNameParts","level","updatePropertyName","destinationCount","propertyRootIndex","propArray","newProperty","srcProp","childProp","getPropertyFromArray","createProperty","addPropertyDestination","properties_2","destinationTargetArray","dstProp","createMapForSourceMember","fluentFunc","cnf","createMapForAllMembers","createMapIgnoreAllNonExisting","createMapConvertToType","typeClass","tcClassOrFunc","TypeConverter","configureSynchronousConverterFunction","convert","functionParameters","typeConverter","e","converterFunc","createMapWithProfile","createMapWithProfileMergeMappings","profileMappingKey","profileMapping","_b","mergeProperty","overwritten","existing","propertyName","arrayIndex","srcKeyOrType","dstKeyOrType","propertiesNew","forMember","prop","valFunc","createMapForMemberNewVersion","forSourceMember","cfgFunc","forAllMembers","type","convertUsing","withProfile","validateForMemberParameters","createSourceProperty","mergeSourceProperty","createDestinationProperty","destinationNameParts","transformations","existingProperties","findProperty","matchSourcePropertyByDestination","existingDestination","getDestinationProperty","handleMapFromProperties","mergeDestinationProperty","newDestination","existingProperty","existingSource","properties_3","properties_4","automapper","app","Profile","argsCopy","CamelCaseNamingConvention","separatorCharacter","toLowerCase","substr","toUpperCase","PascalCaseNamingConvention"],"mappings":"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","file":"automapper.min.js","sourcesContent":["/// <reference path=\"AutoMapperEnumerations.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper helper functions\n     */\n    var AutoMapperHelper = (function () {\n        function AutoMapperHelper() {\n        }\n        AutoMapperHelper.getClassName = function (classType) {\n            if (classType && classType.name) {\n                return classType.name;\n            }\n            // source: http://stackoverflow.com/a/13914278/702357\n            if (classType && classType.constructor) {\n                var className = classType.toString();\n                if (className) {\n                    // classType.toString() is \"function classType (...) { ... }\"\n                    var matchParts = className.match(/function\\s*(\\w+)/);\n                    if (matchParts && matchParts.length === 2) {\n                        return matchParts[1];\n                    }\n                }\n                // for browsers which have name property in the constructor\n                // of the object, such as chrome\n                if (classType.constructor.name) {\n                    return classType.constructor.name;\n                }\n                if (classType.constructor.toString()) {\n                    var str = classType.constructor.toString();\n                    if (str.charAt(0) === '[') {\n                        // executed if the return of object.constructor.toString() is \"[object objectClass]\"\n                        var arr = str.match(/\\[\\w+\\s*(\\w+)\\]/);\n                    }\n                    else {\n                        // executed if the return of object.constructor.toString() is \"function objectClass () {}\"\n                        // (IE and Firefox)\n                        var arr = str.match(/function\\s*(\\w+)/);\n                    }\n                    if (arr && arr.length === 2) {\n                        return arr[1];\n                    }\n                }\n            }\n            throw new Error(\"Unable to extract class name from type '\" + classType + \"'\");\n        };\n        AutoMapperHelper.getFunctionParameters = function (functionStr) {\n            var stripComments = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n            var argumentNames = /([^\\s,]+)/g;\n            var functionString = functionStr.replace(stripComments, '');\n            var functionParameterNames = functionString.slice(functionString.indexOf('(') + 1, functionString.indexOf(')')).match(argumentNames);\n            if (functionParameterNames === null) {\n                functionParameterNames = new Array();\n            }\n            return functionParameterNames;\n        };\n        AutoMapperHelper.handleCurrying = function (func, args, closure) {\n            var argumentsStillToCome = func.length - args.length;\n            // saved accumulator array\n            // NOTE BL this does not deep copy array objects, only the array itself; should side effects occur, please report (or refactor).\n            var argumentsCopy = Array.prototype.slice.apply(args);\n            function accumulator(moreArgs, alreadyProvidedArgs, stillToCome) {\n                var previousAlreadyProvidedArgs = alreadyProvidedArgs.slice(0); // to reset\n                var previousStillToCome = stillToCome; // to reset\n                for (var i = 0; i < moreArgs.length; i++, stillToCome--) {\n                    alreadyProvidedArgs[alreadyProvidedArgs.length] = moreArgs[i];\n                }\n                if (stillToCome - moreArgs.length <= 0) {\n                    var functionCallResult = func.apply(closure, alreadyProvidedArgs);\n                    // reset vars, so curried function can be applied to new params.\n                    alreadyProvidedArgs = previousAlreadyProvidedArgs;\n                    stillToCome = previousStillToCome;\n                    return functionCallResult;\n                }\n                else {\n                    return function () {\n                        // arguments are params, so closure bussiness is avoided.\n                        return accumulator(arguments, alreadyProvidedArgs.slice(0), stillToCome);\n                    };\n                }\n            }\n            return accumulator([], argumentsCopy, argumentsStillToCome);\n        };\n        AutoMapperHelper.getMappingMetadataFromTransformationFunction = function (destination, func, sourceMapping) {\n            if (typeof func !== 'function') {\n                return {\n                    destination: destination,\n                    source: destination,\n                    transformation: AutoMapperHelper.getDestinationTransformation(func, false, sourceMapping, false),\n                    sourceMapping: sourceMapping,\n                    condition: null,\n                    ignore: false,\n                    async: false\n                };\n            }\n            var functionStr = func.toString();\n            var parameterNames = AutoMapperHelper.getFunctionParameters(functionStr);\n            var optsParamName = parameterNames.length >= 1 ? parameterNames[0] : '';\n            var source = sourceMapping\n                ? destination\n                : AutoMapperHelper.getMapFromString(functionStr, destination, optsParamName);\n            var metadata = {\n                destination: destination,\n                source: source,\n                transformation: AutoMapperHelper.getDestinationTransformation(func, true, sourceMapping, parameterNames.length === 2),\n                sourceMapping: sourceMapping,\n                condition: null,\n                ignore: AutoMapperHelper.getIgnoreFromString(functionStr, destination),\n                async: parameterNames.length === 2\n            };\n            // calling the member options function when used asynchronous would be too 'dangerous'.\n            if (!metadata.async && AutoMapperHelper.getFunctionCallIndex(functionStr, 'condition', optsParamName) >= 0) {\n                metadata.condition = AutoMapperHelper.getConditionFromFunction(func, source);\n            }\n            return metadata;\n        };\n        AutoMapperHelper.getDestinationTransformation = function (func, isFunction, sourceMapping, async) {\n            if (!isFunction) {\n                return {\n                    transformationType: AutoMapperJs.DestinationTransformationType.Constant,\n                    constant: func\n                };\n            }\n            var transformation;\n            if (sourceMapping) {\n                if (async) {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.AsyncSourceMemberOptions,\n                        asyncSourceMemberConfigurationOptionsFunc: func\n                    };\n                }\n                else {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.SourceMemberOptions,\n                        sourceMemberConfigurationOptionsFunc: func\n                    };\n                }\n            }\n            else {\n                if (async) {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.AsyncMemberOptions,\n                        asyncMemberConfigurationOptionsFunc: func\n                    };\n                }\n                else {\n                    transformation = {\n                        transformationType: AutoMapperJs.DestinationTransformationType.MemberOptions,\n                        memberConfigurationOptionsFunc: func\n                    };\n                }\n            }\n            return transformation;\n        };\n        AutoMapperHelper.getIgnoreFromString = function (functionString, optionsParameterName) {\n            var indexOfIgnore = AutoMapperHelper.getFunctionCallIndex(functionString, 'ignore', optionsParameterName);\n            if (indexOfIgnore < 0) {\n                return false;\n            }\n            var indexOfMapFromStart = functionString.indexOf('(', indexOfIgnore) + 1;\n            var indexOfMapFromEnd = functionString.indexOf(')', indexOfMapFromStart);\n            if (indexOfMapFromStart < 0 || indexOfMapFromEnd < 0) {\n                return false;\n            }\n            var ignoreString = functionString.substring(indexOfMapFromStart, indexOfMapFromEnd).replace(/\\r/g, '').replace(/\\n/g, '').trim();\n            return ignoreString === null || ignoreString === ''\n                ? true // <optionsParameterName>.ignore()\n                : false; // <optionsParameterName>.ignore(<ignoreString> -> unexpected content)\n        };\n        AutoMapperHelper.getMapFromString = function (functionString, defaultValue, optionsParameterName) {\n            var indexOfMapFrom = AutoMapperHelper.getFunctionCallIndex(functionString, 'mapFrom', optionsParameterName);\n            if (indexOfMapFrom < 0) {\n                return defaultValue;\n            }\n            var indexOfMapFromStart = functionString.indexOf('(', indexOfMapFrom) + 1;\n            var indexOfMapFromEnd = functionString.indexOf(')', indexOfMapFromStart);\n            if (indexOfMapFromStart < 0 || indexOfMapFromEnd < 0) {\n                return defaultValue;\n            }\n            var mapFromString = functionString.substring(indexOfMapFromStart, indexOfMapFromEnd).replace(/'/g, '').replace(/\"/g, '').trim();\n            return mapFromString === null || mapFromString === ''\n                ? defaultValue\n                : mapFromString;\n        };\n        AutoMapperHelper.getFunctionCallIndex = function (functionString, functionToLookFor, optionsParameterName) {\n            var indexOfFunctionCall = functionString.indexOf(optionsParameterName + '.' + functionToLookFor);\n            if (indexOfFunctionCall < 0) {\n                indexOfFunctionCall = functionString.indexOf('.' + functionToLookFor);\n            }\n            return indexOfFunctionCall;\n        };\n        AutoMapperHelper.getConditionFromFunction = function (func, sourceProperty) {\n            // Since we are calling the valueOrFunction function to determine whether to ignore or map from another property, we\n            // want to prevent the call to be error prone when the end user uses the '(opts)=> opts.sourceObject.sourcePropertyName'\n            // syntax. We don't actually have a source object when creating a mapping; therefore, we 'stub' a source object for the\n            // function call.\n            var sourceObject = {};\n            sourceObject[sourceProperty] = {};\n            var condition;\n            // calling the function will result in calling our stubbed ignore() and mapFrom() functions if used inside the function.\n            var configFuncOptions = {\n                ignore: function () {\n                    // do nothing\n                },\n                condition: function (predicate) {\n                    condition = predicate;\n                },\n                mapFrom: function (sourcePropertyName) {\n                    // do nothing\n                },\n                sourceObject: sourceObject,\n                sourcePropertyName: sourceProperty,\n                intermediatePropertyValue: {}\n            };\n            try {\n                func(configFuncOptions);\n            }\n            catch (exc) {\n            }\n            return condition;\n        };\n        return AutoMapperHelper;\n    }());\n    AutoMapperJs.AutoMapperHelper = AutoMapperHelper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperHelper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper configuration validator.\n     */\n    var AutoMapperValidator = (function () {\n        function AutoMapperValidator() {\n        }\n        /**\n         * Validates mapping configuration by dry-running. Since JS does not\n         * fully support typing, it only checks if properties match on both\n         * sides. The function needs IMapping.sourceTypeClass and\n         * IMapping.destinationTypeClass to function.\n         * @param {boolean} strictMode Whether or not to fail when properties\n         *                             sourceTypeClass or destinationTypeClass\n         *                             are unavailable.\n         */\n        AutoMapperValidator.assertConfigurationIsValid = function (mappings, strictMode) {\n            for (var key in mappings) {\n                if (!mappings.hasOwnProperty(key)) {\n                    continue;\n                }\n                AutoMapperValidator.assertMappingConfiguration(mappings[key], strictMode);\n            }\n        };\n        AutoMapperValidator.assertMappingConfiguration = function (mapping, strictMode) {\n            var mappingKey = mapping.sourceKey + \"=>\" + mapping.destinationKey;\n            var sourceType = mapping.sourceTypeClass;\n            var destinationType = mapping.destinationTypeClass;\n            var sourceClassName = sourceType ? AutoMapperJs.AutoMapperHelper.getClassName(sourceType) : undefined;\n            var destinationClassName = destinationType ? AutoMapperJs.AutoMapperHelper.getClassName(destinationType) : undefined;\n            if (!sourceType || !destinationType) {\n                if (strictMode === false) {\n                    return;\n                }\n                throw new Error(\"Mapping '\" + mappingKey + \"' cannot be validated, since mapping.sourceType or mapping.destinationType are unspecified.\");\n            }\n            var tryHandle = function (errorMessage) {\n                if (errorMessage) {\n                    throw new Error(\"Mapping '\" + mappingKey + \"' is invalid: \" + errorMessage + \" (source: '\" + sourceClassName + \"', destination: '\" + destinationClassName + \"').\");\n                }\n            };\n            var validatedMembers = new Array();\n            var srcObj = new sourceType();\n            var dstObj = new destinationType();\n            // walk member mappings\n            for (var _i = 0, _a = mapping.properties; _i < _a.length; _i++) {\n                var property = _a[_i];\n                tryHandle(AutoMapperValidator.validatePropertyMapping(property, property.name, srcObj, dstObj));\n                validatedMembers.push(property.name);\n            }\n            // walk source members\n            for (var srcMember in srcObj) {\n                if (!srcObj.hasOwnProperty(srcMember)) {\n                    continue;\n                }\n                if (validatedMembers.indexOf(srcMember) >= 0) {\n                    // already validated\n                    continue;\n                }\n                tryHandle(AutoMapperValidator.validateProperty(srcMember, dstObj));\n                validatedMembers.push(srcMember);\n            }\n            // walk destination members\n            for (var dstMember in dstObj) {\n                if (!dstObj.hasOwnProperty(dstMember)) {\n                    continue;\n                }\n                if (validatedMembers.indexOf(dstMember) >= 0) {\n                    // already validated\n                    continue;\n                }\n                tryHandle(\"Destination member '\" + dstMember + \"' does not exist on source type\");\n            }\n            // /* tslint:disable */\n            // console.error(key);\n            // /* tslint:enable */            \n        };\n        AutoMapperValidator.validatePropertyMapping = function (propertyMapping, member, srcObj, dstObj) {\n            return propertyMapping.sourceMapping\n                ? AutoMapperValidator.validateSourcePropertyMapping(propertyMapping, member, srcObj, dstObj)\n                : AutoMapperValidator.validateDestinationPropertyMapping(propertyMapping, member, srcObj, dstObj);\n        };\n        AutoMapperValidator.validateSourcePropertyMapping = function (propertyMapping, member, srcObj, dstObj) {\n            // a member for which configuration is provided, should exist.\n            if (!srcObj.hasOwnProperty(member)) {\n                return \"Source member '\" + member + \"' is configured, but does not exist on source type\";\n            }\n            // an ignored source member should not exist on the destination type. \n            if (propertyMapping.ignore) {\n                if (dstObj.hasOwnProperty(member)) {\n                    return \"Source member '\" + member + \"' is ignored, but does exist on destination type\";\n                }\n                return undefined;\n            }\n            // a mapped source member should exist on the destination type.\n            if (!dstObj.hasOwnProperty(member)) {\n                return \"Source member '\" + member + \"' is configured to be mapped, but does not exist on destination type\";\n            }\n            //var dstMember = propertyMapping.destinationProperty;\n            return undefined;\n        };\n        AutoMapperValidator.validateDestinationPropertyMapping = function (propertyMapping, member, srcObj, dstObj) {\n            // a member for which configuration is provided, should exist.\n            if (!dstObj.hasOwnProperty(member)) {\n                return \"Destination member '\" + member + \"' is configured, but does not exist on destination type\";\n            }\n            // an ignored destination member should not exist on the source type. \n            if (propertyMapping.ignore) {\n                if (srcObj.hasOwnProperty(member)) {\n                    return \"Destination member '\" + member + \"' is ignored, but does exist on source type\";\n                }\n                return undefined;\n            }\n            // a mapped destination member should exist on the source type.\n            if (!srcObj.hasOwnProperty(member)) {\n                return \"Destination member '\" + member + \"' is configured to be mapped, but does not exist on source type\";\n            }\n            //var dstMember = propertyMapping.destinationProperty;\n            return undefined;\n        };\n        AutoMapperValidator.validateProperty = function (srcMember, dstObj) {\n            if (!dstObj.hasOwnProperty(srcMember)) {\n                return \"Source member '\" + srcMember + \"' is configured to be mapped, but does not exist on destination type\";\n            }\n            return undefined;\n        };\n        return AutoMapperValidator;\n    }());\n    AutoMapperJs.AutoMapperValidator = AutoMapperValidator;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperValidator.js.map\n","var AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    (function (DestinationTransformationType) {\n        DestinationTransformationType[DestinationTransformationType[\"Constant\"] = 1] = \"Constant\";\n        DestinationTransformationType[DestinationTransformationType[\"MemberOptions\"] = 2] = \"MemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"AsyncMemberOptions\"] = 4] = \"AsyncMemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"SourceMemberOptions\"] = 8] = \"SourceMemberOptions\";\n        DestinationTransformationType[DestinationTransformationType[\"AsyncSourceMemberOptions\"] = 16] = \"AsyncSourceMemberOptions\";\n    })(AutoMapperJs.DestinationTransformationType || (AutoMapperJs.DestinationTransformationType = {}));\n    var DestinationTransformationType = AutoMapperJs.DestinationTransformationType;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperEnumerations.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\n     * .NET AutoMapper library is the pursuit of this implementation.\n     */\n    var AutoMapperBase = (function () {\n        function AutoMapperBase() {\n        }\n        AutoMapperBase.prototype.getMapping = function (mappings, sourceKey, destinationKey) {\n            var srcKey = this.getKey(sourceKey);\n            var dstKey = this.getKey(destinationKey);\n            var mapping = mappings[srcKey + dstKey];\n            if (!mapping) {\n                throw new Error(\"Could not find map object with a source of \" + srcKey + \" and a destination of \" + dstKey);\n            }\n            return mapping;\n        };\n        AutoMapperBase.prototype.getKey = function (keyStringOrType) {\n            if (typeof keyStringOrType === 'string') {\n                return keyStringOrType;\n            }\n            else {\n                return AutoMapperJs.AutoMapperHelper.getClassName(keyStringOrType);\n            }\n        };\n        AutoMapperBase.prototype.isArray = function (sourceObject) {\n            return sourceObject instanceof Array;\n        };\n        AutoMapperBase.prototype.handleArray = function (mapping, sourceArray, itemFunc) {\n            var arrayLength = sourceArray.length;\n            var destinationArray = new Array(sourceArray.length);\n            for (var index = 0; index < arrayLength; index++) {\n                var sourceObject = sourceArray[index];\n                var destinationObject = void 0;\n                if (sourceObject === null || sourceObject === undefined) {\n                    destinationObject = sourceObject;\n                }\n                else {\n                    destinationObject = this.createDestinationObject(mapping.destinationTypeClass);\n                    itemFunc(sourceObject, destinationObject);\n                }\n                destinationArray[index] = destinationObject;\n            }\n            return destinationArray;\n        };\n        AutoMapperBase.prototype.handleItem = function (mapping, sourceObject, destinationObject, propertyFunction) {\n            var sourceProperties = [];\n            var atLeastOnePropertyMapped = false;\n            for (var sourcePropertyName in sourceObject) {\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\n                    continue;\n                }\n                atLeastOnePropertyMapped = true;\n                sourceProperties.push(sourcePropertyName);\n                propertyFunction(sourcePropertyName);\n            }\n            // unsourced properties\n            for (var _i = 0, _a = mapping.properties; _i < _a.length; _i++) {\n                var property = _a[_i];\n                if (sourceProperties.indexOf(property.name) >= 0) {\n                    continue;\n                }\n                atLeastOnePropertyMapped = true;\n                propertyFunction(property.name);\n            }\n            // return null/undefined sourceObject if no properties added\n            if (!atLeastOnePropertyMapped && sourceObject === null || sourceObject === undefined) {\n                return sourceObject;\n            }\n            return destinationObject;\n        };\n        AutoMapperBase.prototype.handleProperty = function (mapping, sourceObject, sourcePropertyName, destinationObject, loopMemberValuesAndFunctions, autoMappingCallbackFunction) {\n            var propertyMapping = this.getMappingProperty(mapping.properties, sourcePropertyName);\n            if (propertyMapping) {\n                this.handlePropertyWithPropertyMapping(mapping, propertyMapping, sourceObject, sourcePropertyName, loopMemberValuesAndFunctions);\n            }\n            else {\n                this.handlePropertyWithAutoMapping(mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction);\n            }\n        };\n        AutoMapperBase.prototype.setPropertyValue = function (mapping, destinationObject, destinationProperty, destinationPropertyValue) {\n            if (mapping.forAllMemberMappings.length > 0) {\n                for (var _i = 0, _a = mapping.forAllMemberMappings; _i < _a.length; _i++) {\n                    var forAllMemberMapping = _a[_i];\n                    this.handleNestedForAllMemberMappings(destinationObject, destinationProperty, destinationPropertyValue, forAllMemberMapping);\n                }\n            }\n            else {\n                this.setNestedPropertyValue(destinationObject, destinationProperty, destinationPropertyValue);\n            }\n        };\n        AutoMapperBase.prototype.setPropertyValueByName = function (mapping, destinationObject, destinationProperty, destinationPropertyValue) {\n            if (mapping.forAllMemberMappings.length > 0) {\n                for (var _i = 0, _a = mapping.forAllMemberMappings; _i < _a.length; _i++) {\n                    var forAllMemberMapping = _a[_i];\n                    forAllMemberMapping(destinationObject, destinationProperty, destinationPropertyValue);\n                }\n            }\n            else {\n                destinationObject[destinationProperty] = destinationPropertyValue;\n            }\n        };\n        AutoMapperBase.prototype.createDestinationObject = function (destinationType) {\n            // create empty destination object.\n            return destinationType\n                ? new destinationType()\n                : {};\n        };\n        AutoMapperBase.prototype.handleNestedForAllMemberMappings = function (destinationObject, destinationProperty, destinationPropertyValue, forAllMemberMapping) {\n            if (destinationProperty.children && destinationProperty.children.length > 0) {\n                this.setChildPropertyValues(destinationObject, destinationProperty, destinationPropertyValue);\n            }\n            else {\n                forAllMemberMapping(destinationObject, destinationProperty.name, destinationPropertyValue);\n            }\n        };\n        AutoMapperBase.prototype.setNestedPropertyValue = function (destinationObject, destinationProperty, destinationPropertyValue) {\n            if (destinationProperty.children && destinationProperty.children.length > 0) {\n                var isSuccess = this.setChildPropertyValues(destinationObject, destinationProperty, destinationPropertyValue);\n                if (!isSuccess) {\n                    destinationObject[destinationProperty.name] = destinationPropertyValue;\n                }\n                return isSuccess;\n            }\n            else {\n                destinationObject[destinationProperty.name] = destinationPropertyValue;\n                return destinationPropertyValue !== undefined && destinationPropertyValue !== null;\n            }\n        };\n        AutoMapperBase.prototype.setChildPropertyValues = function (destinationObject, destinationProperty, destinationPropertyValue) {\n            var dstObj = {};\n            var destinationAlreadyExists = destinationObject.hasOwnProperty(destinationProperty.name) && destinationObject[destinationProperty.name];\n            var isSuccess;\n            for (var index = 0, count = destinationProperty.children.length; index < count; index++) {\n                var tmpObj = {};\n                var child = destinationProperty.children[index];\n                var isChildSucces = this.setNestedPropertyValue(tmpObj, child, destinationPropertyValue);\n                if (isChildSucces) {\n                    dstObj[child.name] = tmpObj[child.name];\n                }\n                isSuccess = isSuccess || isChildSucces;\n            }\n            if (isSuccess) {\n                if (destinationAlreadyExists) {\n                    for (var child_1 in dstObj) {\n                        if (!dstObj.hasOwnProperty(child_1)) {\n                            continue;\n                        }\n                        destinationObject[destinationProperty.name][child_1] = dstObj[child_1];\n                    }\n                }\n                else {\n                    destinationObject[destinationProperty.name] = dstObj;\n                }\n            }\n            return destinationAlreadyExists || isSuccess;\n        };\n        AutoMapperBase.prototype.getMappingProperty = function (properties, sourcePropertyName) {\n            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n                var property = properties_1[_i];\n                if (property.name === sourcePropertyName) {\n                    return property;\n                }\n            }\n            return null;\n        };\n        AutoMapperBase.prototype.handlePropertyWithAutoMapping = function (mapping, sourceObject, sourcePropertyName, destinationObject, autoMappingCallbackFunction) {\n            // no forMember mapping exists, auto map properties, except for the situation where ignoreAllNonExisting is specified.\n            if (mapping.ignoreAllNonExisting) {\n                return;\n            }\n            if (mapping.destinationTypeClass && Object.keys(destinationObject).indexOf(sourcePropertyName) < 0) {\n                return;\n            }\n            var objectValue = null;\n            var isNestedObject = false;\n            if (typeof destinationObject[sourcePropertyName] === 'object' && destinationObject[sourcePropertyName]) {\n                isNestedObject = (destinationObject[sourcePropertyName].constructor.name !== 'Object');\n                if (isNestedObject) {\n                    this\n                        .createMap(sourceObject[sourcePropertyName].constructor.name, destinationObject[sourcePropertyName].constructor.name)\n                        .convertToType(destinationObject[sourcePropertyName].constructor);\n                    objectValue = this.map(sourceObject[sourcePropertyName].constructor.name, destinationObject[sourcePropertyName].constructor.name, sourceObject[sourcePropertyName]);\n                }\n            }\n            // use profile mapping when specified; otherwise, specify source property name as destination property name.\n            var destinationPropertyName = this.getDestinationPropertyName(mapping.profile, sourcePropertyName);\n            var destinationPropertyValue = this.getDestinationPropertyValue(sourceObject, sourcePropertyName, objectValue, isNestedObject);\n            this.setPropertyValueByName(mapping, destinationObject, destinationPropertyName, destinationPropertyValue);\n            if (autoMappingCallbackFunction) {\n                autoMappingCallbackFunction(destinationPropertyValue);\n            }\n        };\n        AutoMapperBase.prototype.getDestinationPropertyValue = function (sourceObject, sourcePropertyName, objectValue, isNestedObject) {\n            if (isNestedObject) {\n                return objectValue;\n            }\n            return sourceObject ? sourceObject[sourcePropertyName] : null;\n        };\n        AutoMapperBase.prototype.handlePropertyWithPropertyMapping = function (mapping, propertyMapping, sourceObject, sourcePropertyName, loopMemberValuesAndFunctions) {\n            // a forMember mapping exists\n            var ignore = propertyMapping.ignore, conditionFunction = propertyMapping.conditionFunction, children = propertyMapping.children, destinations = propertyMapping.destinations, conversionValuesAndFunctions = propertyMapping.conversionValuesAndFunctions;\n            if (children) {\n                var childSourceObject = sourceObject[propertyMapping.name];\n                for (var index = 0; index < children.length; index++) {\n                    var child = children[index];\n                    this.handlePropertyWithPropertyMapping(mapping, child, childSourceObject, child.name, loopMemberValuesAndFunctions);\n                }\n            }\n            // ignore ignored properties\n            if (ignore) {\n                return;\n            }\n            // check for condition function\n            if (conditionFunction) {\n                // and, if there, return when the condition is not met.\n                if (conditionFunction(sourceObject) === false) {\n                    return;\n                }\n            }\n            // it makes no sense to handle a property without destination(s).\n            if (!destinations) {\n                return;\n            }\n            var memberConfigurationOptions = {\n                mapFrom: function () {\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\n                },\n                condition: function (predicate) {\n                    // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\n                },\n                sourceObject: sourceObject,\n                sourcePropertyName: sourcePropertyName,\n                intermediatePropertyValue: sourceObject ? sourceObject[sourcePropertyName] : sourceObject\n            };\n            loopMemberValuesAndFunctions(destinations, conversionValuesAndFunctions, memberConfigurationOptions);\n        };\n        AutoMapperBase.prototype.getDestinationPropertyName = function (profile, sourcePropertyName) {\n            if (!profile) {\n                return sourcePropertyName;\n            }\n            // TODO BL no support yet for INamingConvention.splittingCharacter\n            try {\n                // First, split the source property name based on the splitting expression.\n                // TODO BL Caching of RegExp splitting!\n                var sourcePropertyNameParts = sourcePropertyName.split(profile.sourceMemberNamingConvention.splittingExpression);\n                // NOTE BL For some reason, splitting by (my ;)) RegExp results in empty strings in the array; remove them.\n                for (var index = sourcePropertyNameParts.length - 1; index >= 0; index--) {\n                    if (sourcePropertyNameParts[index] === '') {\n                        sourcePropertyNameParts.splice(index, 1);\n                    }\n                }\n                return profile.destinationMemberNamingConvention.transformPropertyName(sourcePropertyNameParts);\n            }\n            catch (error) {\n                return sourcePropertyName;\n            }\n        };\n        return AutoMapperBase;\n    }());\n    AutoMapperJs.AutoMapperBase = AutoMapperBase;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AutoMapperBase.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapper.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * AsyncAutoMapper implementation, for asynchronous mapping support when using AutoMapper.\n     */\n    var AsyncAutoMapper = (function (_super) {\n        __extends(AsyncAutoMapper, _super);\n        function AsyncAutoMapper() {\n            _super.call(this);\n            AsyncAutoMapper.asyncInstance = this;\n        }\n        AsyncAutoMapper.prototype.createMap = function (sourceKeyOrType, destinationKeyOrType) {\n            throw new Error('Method AsyncAutoMapper.createMap is not implemented.');\n        };\n        AsyncAutoMapper.prototype.createMapForMember = function (property, func, metadata) {\n            var _this = this;\n            var mapping = property.metadata.mapping;\n            mapping.async = true;\n            mapping.mapItemFunction = function (m, srcObj, dstObj, cb) { return _this.mapItem(m, srcObj, dstObj, cb); };\n            property.async = true;\n            property.conversionValuesAndFunctions.push(func);\n        };\n        AsyncAutoMapper.prototype.createMapConvertUsing = function (mapping, converterFunction) {\n            var _this = this;\n            mapping.async = true;\n            mapping.typeConverterFunction = converterFunction;\n            mapping.mapItemFunction = function (m, srcObj, dstObj, cb) { return _this.mapItemUsingTypeConverter(m, srcObj, dstObj, cb); };\n        };\n        AsyncAutoMapper.prototype.map = function (mappings, sourceKey, destinationKey, sourceObject, callback) {\n            var _this = this;\n            switch (arguments.length) {\n                case 5:\n                    this.mapWithMapping(_super.prototype.getMapping.call(this, mappings, sourceKey, destinationKey), sourceObject, callback);\n                    return;\n                // provide performance optimized (preloading) currying support.\n                case 4:\n                    return function (cb) { return _this.mapWithMapping(_super.prototype.getMapping.call(_this, mappings, sourceKey, destinationKey), sourceObject, cb); };\n                case 3:\n                    return function (srcObj, cb) { return _this.mapWithMapping(_super.prototype.getMapping.call(_this, mappings, sourceKey, destinationKey), srcObj, cb); };\n                case 2:\n                    return function (dstKey, srcObj, cb) { return _this.map(mappings, sourceKey, dstKey, srcObj, cb); };\n                default:\n                    throw new Error('The AsyncAutoMapper.map function expects between 2 and 5 parameters, you provided ' + arguments.length + '.');\n            }\n        };\n        AsyncAutoMapper.prototype.mapWithMapping = function (mapping, sourceObject, callback) {\n            if (_super.prototype.isArray.call(this, sourceObject)) {\n                this.mapArray(mapping, sourceObject, callback);\n                return;\n            }\n            return mapping.mapItemFunction(mapping, sourceObject, _super.prototype.createDestinationObject.call(this, mapping.destinationTypeClass), callback);\n        };\n        /**\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceArray The source array to map.\n         * @returns {Array<any>} Destination array.\n         */\n        AsyncAutoMapper.prototype.mapArray = function (mapping, sourceArray, callback) {\n            var callbacksToGo = 0;\n            var destinationArray = _super.prototype.handleArray.call(this, mapping, sourceArray, function (sourceObject, destinationObject) {\n                callbacksToGo++;\n                mapping.mapItemFunction(mapping, sourceObject, destinationObject, function (result) {\n                    callbacksToGo--;\n                });\n            });\n            var waitForCallbackToSend = function () {\n                if (callbacksToGo === 0) {\n                    callback(destinationArray);\n                }\n                else {\n                    setTimeout(function () {\n                        waitForCallbackToSend();\n                    }, 10 * callbacksToGo);\n                }\n            };\n            waitForCallbackToSend();\n        };\n        AsyncAutoMapper.prototype.mapItemUsingTypeConverter = function (mapping, sourceObject, destinationObject, callback) {\n            var resolutionContext = {\n                sourceValue: sourceObject,\n                destinationValue: destinationObject\n            };\n            mapping.typeConverterFunction(resolutionContext, callback);\n        };\n        /**\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceObject The source object to map.\n         * @param destinationObject The destination object to map to.\n         * @param callback The callback to call after async mapping has been executed.\n         */\n        AsyncAutoMapper.prototype.mapItem = function (mapping, sourceObject, destinationObject, callback) {\n            var _this = this;\n            var callbacksToGo = 0;\n            _super.prototype.handleItem.call(this, mapping, sourceObject, destinationObject, function (sourceProperty) {\n                callbacksToGo++;\n                _this.mapProperty(mapping, sourceObject, sourceProperty, destinationObject, function (result) {\n                    callbacksToGo--;\n                });\n            });\n            var waitForCallbackToSend = function () {\n                if (callbacksToGo === 0) {\n                    callback(destinationObject);\n                }\n                else {\n                    setTimeout(function () {\n                        waitForCallbackToSend();\n                    }, 10 * callbacksToGo);\n                }\n            };\n            waitForCallbackToSend();\n        };\n        /**\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\n         * @param mapping The mapping configuration for the current mapping keys/types.\n         * @param sourceObject The source object to map.\n         * @param sourcePropertyName The source property to map.\n         * @param destinationObject The destination object to map to.\n         * @param callback The callback to call after async property mapping has been executed.\n         */\n        AsyncAutoMapper.prototype.mapProperty = function (mapping, sourceObject, sourceProperty, destinationObject, callback) {\n            var _this = this;\n            _super.prototype.handleProperty.call(this, mapping, sourceObject, sourceProperty, destinationObject, function (destinations, valuesAndFunctions, opts) {\n                _this.handlePropertyMappings(valuesAndFunctions, opts, function (destinationPropertyValue) {\n                    for (var _i = 0, destinations_1 = destinations; _i < destinations_1.length; _i++) {\n                        var destination = destinations_1[_i];\n                        _super.prototype.setPropertyValue.call(_this, mapping, destinationObject, destination, destinationPropertyValue);\n                    }\n                    callback(destinationPropertyValue);\n                });\n            }, function (destinationPropertyValue) {\n                callback(destinationPropertyValue);\n            });\n        };\n        AsyncAutoMapper.prototype.handlePropertyMappings = function (valuesAndFunctions, opts, callback) {\n            var _this = this;\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\n                callback(opts.intermediatePropertyValue);\n                return;\n            }\n            var valueOrFunction = valuesAndFunctions[0];\n            if (typeof valueOrFunction === 'function') {\n                this.handlePropertyMappingFunction(valueOrFunction, opts, function (result) {\n                    if (typeof result !== 'undefined') {\n                        opts.intermediatePropertyValue = result;\n                        // recursively walk values/functions\n                        _this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\n                    }\n                });\n            }\n            else {\n                // valueOrFunction is a value\n                opts.intermediatePropertyValue = valueOrFunction;\n                // recursively walk values/functions\n                this.handlePropertyMappings(valuesAndFunctions.slice(1), opts, callback);\n            }\n        };\n        AsyncAutoMapper.prototype.handlePropertyMappingFunction = function (func, opts, callback) {\n            // check if function is asynchronous\n            var args = AutoMapperJs.AutoMapperHelper.getFunctionParameters(func.toString());\n            if (args.length === 2) {\n                func(opts, callback);\n                return;\n            }\n            callback(func(opts));\n        };\n        AsyncAutoMapper.asyncInstance = new AsyncAutoMapper();\n        return AsyncAutoMapper;\n    }(AutoMapperJs.AutoMapperBase));\n    AutoMapperJs.AsyncAutoMapper = AsyncAutoMapper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=AsyncAutoMapper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"AutoMapperEnumerations.ts\" />\n/// <reference path=\"AutoMapperBase.ts\" />\n/// <reference path=\"AsyncAutoMapper.ts\" />\n/// <reference path=\"TypeConverter.ts\" />\n/// <reference path=\"AutoMapperHelper.ts\" />\n/// <reference path=\"AutoMapperValidator.ts\" />\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var AutoMapper = (function (_super) {\n        __extends(AutoMapper, _super);\n        /**\n         * This class is intended to be a Singleton. Preferrably use getInstance()\n         * function instead of using the constructor directly from code.\n         */\n        function AutoMapper() {\n            _super.call(this);\n            if (AutoMapper._instance) {\n                return AutoMapper._instance;\n            }\n            else {\n                AutoMapper._instance = this;\n                this._profiles = {};\n                this._mappings = {};\n                this._asyncMapper = new AutoMapperJs.AsyncAutoMapper();\n            }\n        }\n        AutoMapper.getInstance = function () {\n            return AutoMapper._instance;\n        };\n        /**\n         * Initializes the mapper with the supplied configuration.\n         * @param {(config: IConfiguration) => void} configFunction Configuration function to call.\n         */\n        AutoMapper.prototype.initialize = function (configFunction) {\n            var that = this;\n            var configuration = {\n                addProfile: function (profile) {\n                    profile.configure();\n                    that._profiles[profile.profileName] = profile;\n                },\n                createMap: function (sourceKey, destinationKey) {\n                    // pass through using arguments to keep createMap's currying support fully functional.\n                    return that.createMap.apply(that, arguments);\n                }\n            };\n            configFunction(configuration);\n        };\n        /**\n         * Create a mapping profile.\n         * @param {string} sourceKey The map source key.\n         * @param {string} destinationKey The map destination key.\n         * @returns {Core.ICreateMapFluentFunctions}\n         */\n        AutoMapper.prototype.createMap = function (sourceKeyOrType, destinationKeyOrType) {\n            // provide currying support.\n            if (arguments.length < 2) {\n                return AutoMapperJs.AutoMapperHelper.handleCurrying(this.createMap, arguments, this);\n            }\n            var mapping = this.createMappingObjectForGivenKeys(sourceKeyOrType, destinationKeyOrType);\n            return this.createMapGetFluentApiFunctions(mapping);\n        };\n        /**\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param sourceKey Source key, for instance the source type name.\n         * @param destinationKey Destination key, for instance the destination type name.\n         * @param sourceObject The source object to map.\n         * @returns {any} Destination object.\n         */\n        AutoMapper.prototype.map = function (sourceKeyOrType, destinationKeyOrType, sourceObject) {\n            var _this = this;\n            if (arguments.length === 3) {\n                return this.mapInternal(_super.prototype.getMapping.call(this, this._mappings, sourceKeyOrType, destinationKeyOrType), sourceObject);\n            }\n            // provide performance optimized (preloading) currying support.\n            if (arguments.length === 2) {\n                return function (srcObj) { return _this.mapInternal(_super.prototype.getMapping.call(_this, _this._mappings, sourceKeyOrType, destinationKeyOrType), srcObj); };\n            }\n            if (arguments.length === 1) {\n                return function (dstKey, srcObj) { return _this.map(sourceKeyOrType, dstKey, srcObj); };\n            }\n            return function (srcKey, dstKey, srcObj) { return _this.map(srcKey, dstKey, srcObj); };\n        };\n        /**\n         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\n         * @param sourceKey Source key, for instance the source type name.\n         * @param destinationKey Destination key, for instance the destination type name.\n         * @param sourceObject The source object to map.\n         * @param {IMapCallback} callback The callback to call when asynchronous mapping is complete.\n         */\n        AutoMapper.prototype.mapAsync = function (sourceKeyOrType, destinationKeyOrType, sourceObject, callback) {\n            switch (arguments.length) {\n                case 4:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject, callback);\n                case 3:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType, sourceObject);\n                case 2:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType, destinationKeyOrType);\n                case 1:\n                    return this._asyncMapper.map(this._mappings, sourceKeyOrType);\n                default:\n                    throw new Error('The mapAsync function expects between 1 and 4 parameters, you provided ' + arguments.length + '.');\n            }\n        };\n        /**\n         * Validates mapping configuration by dry-running. Since JS does not fully support typing, it only checks if properties match on both\n         * sides. The function needs IMapping.sourceTypeClass and IMapping.destinationTypeClass to function.\n         * @param {boolean} strictMode Whether or not to fail when properties sourceTypeClass or destinationTypeClass are unavailable.\n         */\n        AutoMapper.prototype.assertConfigurationIsValid = function (strictMode) {\n            if (strictMode === void 0) { strictMode = true; }\n            AutoMapperJs.AutoMapperValidator.assertConfigurationIsValid(this._mappings, strictMode);\n        };\n        AutoMapper.prototype.createMapForMember = function (parameters) {\n            var mapping = parameters.mapping, destinationProperty = parameters.destinationProperty, conversionValueOrFunction = parameters.conversionValueOrFunction, sourceMapping = parameters.sourceMapping, fluentFunctions = parameters.fluentFunctions;\n            var metadata = AutoMapperJs.AutoMapperHelper.getMappingMetadataFromTransformationFunction(destinationProperty, conversionValueOrFunction, sourceMapping);\n            var property;\n            if (!sourceMapping) {\n                property = this.getPropertyByDestinationProperty(mapping.properties, destinationProperty);\n            }\n            if (!property) {\n                property = this.getOrCreateProperty({\n                    propertyNameParts: metadata.source.split('.'),\n                    mapping: mapping,\n                    propertyArray: mapping.properties,\n                    parent: null,\n                    destination: destinationProperty,\n                    sourceMapping: sourceMapping\n                });\n            }\n            if (this.createMapForMemberHandleIgnore(property, metadata)) {\n                return fluentFunctions;\n            }\n            if (metadata.async) {\n                this._asyncMapper.createMapForMember(property, conversionValueOrFunction, metadata);\n                return fluentFunctions;\n            }\n            this.createMapForMemberHandleMapFrom(property, metadata);\n            property.conditionFunction = metadata.condition;\n            property.conversionValuesAndFunctions.push(conversionValueOrFunction);\n            return fluentFunctions;\n        };\n        AutoMapper.prototype.createMapForMemberHandleMapFrom = function (property, metadata) {\n            if (metadata.source === metadata.destination) {\n                return;\n            }\n            var _a = property.metadata, mapping = _a.mapping, root = _a.root;\n            var sourceNameParts = metadata.source.split('.');\n            if (sourceNameParts.length === property.level) {\n                this.updatePropertyName(sourceNameParts, property);\n                return;\n            }\n            // check if only one destination on property root. in that case, rebase property and overwrite root.\n            if (root.metadata.destinationCount !== 1) {\n                throw new Error('Rebasing properties with multiple destinations is not yet implemented.');\n            }\n            var propertyRootIndex = mapping.properties.indexOf(root);\n            mapping.properties[propertyRootIndex] = undefined;\n            var propArray = [];\n            var newProperty = this.getOrCreateProperty({\n                propertyNameParts: metadata.source.split('.'),\n                mapping: mapping,\n                propertyArray: propArray,\n                destination: metadata.destination,\n                sourceMapping: metadata.sourceMapping\n            });\n            newProperty.conditionFunction = property.conditionFunction;\n            newProperty.conversionValuesAndFunctions = property.conversionValuesAndFunctions;\n            mapping.properties[propertyRootIndex] = propArray[0];\n        };\n        AutoMapper.prototype.updatePropertyName = function (sourceNameParts, property) {\n            property.name = sourceNameParts[sourceNameParts.length - 1];\n            if (sourceNameParts.length === 1) {\n                return;\n            }\n            this.updatePropertyName(sourceNameParts.splice(0, 1), property.metadata.parent);\n        };\n        AutoMapper.prototype.createMapForMemberHandleIgnore = function (property, metadata) {\n            if (property.ignore || metadata.ignore) {\n                // source name will always be destination name when ignoring.\n                property.name = metadata.destination;\n                property.ignore = true;\n                property.async = false;\n                property.destinations = null;\n                property.conversionValuesAndFunctions = [];\n                return true;\n            }\n            return false;\n        };\n        AutoMapper.prototype.getPropertyByDestinationProperty = function (properties, destinationPropertyName) {\n            if (properties === null || properties === undefined) {\n                return null;\n            }\n            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n                var srcProp = properties_1[_i];\n                if (srcProp.metadata.destinations !== null && srcProp.metadata.destinations !== undefined) {\n                    for (var destination in srcProp.metadata.destinations) {\n                        if (destination === destinationPropertyName) {\n                            return srcProp.metadata.destinations[destination].source;\n                        }\n                    }\n                }\n                var childProp = this.getPropertyByDestinationProperty(srcProp.children, destinationPropertyName);\n                if (childProp != null) {\n                    return childProp;\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.getOrCreateProperty = function (parameters) {\n            var propertyNameParts = parameters.propertyNameParts, mapping = parameters.mapping, parent = parameters.parent, propertyArray = parameters.propertyArray, destination = parameters.destination, sourceMapping = parameters.sourceMapping;\n            var name = propertyNameParts[0];\n            var property = this.getPropertyFromArray(name, propertyArray);\n            if (!property) {\n                property = this.createProperty({\n                    name: name,\n                    parent: parent,\n                    propertyArray: propertyArray,\n                    sourceMapping: sourceMapping,\n                    mapping: mapping\n                });\n            }\n            if (propertyNameParts.length === 1) {\n                this.addPropertyDestination(property, destination, mapping, sourceMapping);\n                return property;\n            }\n            if (!property.children) {\n                property.children = [];\n            }\n            // nested call\n            return this.getOrCreateProperty({\n                propertyNameParts: propertyNameParts.slice(1),\n                mapping: mapping,\n                propertyArray: property.children,\n                parent: property,\n                destination: destination,\n                sourceMapping: sourceMapping\n            });\n        };\n        AutoMapper.prototype.getPropertyFromArray = function (name, properties) {\n            if (properties) {\n                for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {\n                    var child = properties_2[_i];\n                    if (child.name === name) {\n                        return child;\n                    }\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.addPropertyDestination = function (property, destination, mapping, sourceMapping) {\n            if (!destination) {\n                return;\n            }\n            var destinationTargetArray = property.destinations ? property.destinations : [];\n            var dstProp = this.getOrCreateProperty({\n                propertyNameParts: destination.split('.'),\n                mapping: mapping,\n                propertyArray: destinationTargetArray,\n                sourceMapping: sourceMapping\n            });\n            if (destinationTargetArray.length > 0) {\n                property.metadata.root.metadata.destinations[destination] = { source: property, destination: dstProp };\n                property.metadata.root.metadata.destinationCount++;\n                property.destinations = destinationTargetArray;\n            }\n        };\n        AutoMapper.prototype.createProperty = function (parameters) {\n            var name = parameters.name, parent = parameters.parent, propertyArray = parameters.propertyArray, sourceMapping = parameters.sourceMapping, mapping = parameters.mapping;\n            var property = {\n                name: name,\n                metadata: {\n                    mapping: mapping,\n                    root: parent ? parent.metadata.root : null,\n                    parent: parent,\n                    destinations: {},\n                    destinationCount: 0\n                },\n                sourceMapping: sourceMapping,\n                level: !parent ? 1 : parent.level + 1,\n                ignore: false,\n                async: false,\n                conversionValuesAndFunctions: []\n            };\n            if (property.metadata.root === null) {\n                property.metadata.root = property;\n            }\n            if (propertyArray) {\n                propertyArray.push(property);\n            }\n            return property;\n        };\n        AutoMapper.prototype.createMapForSourceMember = function (mapping, fluentFunc, srcProp, cnf) {\n            if (typeof cnf !== 'function') {\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\n            }\n            return this.createMapForMember({\n                mapping: mapping,\n                fluentFunctions: fluentFunc,\n                destinationProperty: srcProp,\n                conversionValueOrFunction: cnf,\n                sourceMapping: true\n            });\n        };\n        AutoMapper.prototype.createMapForAllMembers = function (mapping, fluentFunc, func) {\n            mapping.forAllMemberMappings.push(func);\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapIgnoreAllNonExisting = function (mapping, fluentFunc) {\n            mapping.ignoreAllNonExisting = true;\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapConvertToType = function (mapping, fluentFunc, typeClass) {\n            if (mapping.destinationTypeClass) {\n                throw new Error('Destination type class can only be set once.');\n            }\n            mapping.destinationTypeClass = typeClass;\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapConvertUsing = function (mapping, tcClassOrFunc) {\n            try {\n                // check if sync: TypeConverter instance\n                if (tcClassOrFunc instanceof AutoMapperJs.TypeConverter) {\n                    this.configureSynchronousConverterFunction(mapping, tcClassOrFunc.convert);\n                    return;\n                }\n                var functionParameters = AutoMapperJs.AutoMapperHelper.getFunctionParameters(tcClassOrFunc.toString());\n                switch (functionParameters.length) {\n                    case 0:\n                        // check if sync: TypeConverter class definition\n                        var typeConverter;\n                        try {\n                            typeConverter = (new tcClassOrFunc());\n                        }\n                        catch (e) {\n                        }\n                        if (typeConverter instanceof AutoMapperJs.TypeConverter) {\n                            this.configureSynchronousConverterFunction(mapping, typeConverter.convert);\n                            return;\n                        }\n                        break;\n                    case 1:\n                        // sync: function with resolutionContext parameter\n                        this.configureSynchronousConverterFunction(mapping, tcClassOrFunc);\n                        return;\n                    case 2:\n                        // check if async: function with resolutionContext and callback parameters\n                        this._asyncMapper.createMapConvertUsing(mapping, tcClassOrFunc);\n                        return;\n                }\n                // okay, just try feeding the function to the configure function anyway...\n                this.configureSynchronousConverterFunction(mapping, tcClassOrFunc);\n            }\n            catch (e) {\n                throw new Error(\"The value provided for typeConverterClassOrFunction is invalid. \" + e);\n            }\n            throw new Error(\"The value provided for typeConverterClassOrFunction is invalid.\");\n        };\n        AutoMapper.prototype.configureSynchronousConverterFunction = function (mapping, converterFunc) {\n            var _this = this;\n            if (!converterFunc || AutoMapperJs.AutoMapperHelper.getFunctionParameters(converterFunc.toString()).length !== 1) {\n                throw new Error('The function provided does not provide exactly one (resolutionContext) parameter.');\n            }\n            mapping.typeConverterFunction = converterFunc;\n            mapping.mapItemFunction = function (m, srcObj, dstObj) { return _this.mapItemUsingTypeConverter(m, srcObj, dstObj); };\n        };\n        AutoMapper.prototype.createMapWithProfile = function (mapping, profileName) {\n            // check if given profile exists\n            var profile = this._profiles[profileName];\n            if (typeof profile === 'undefined' || profile.profileName !== profileName) {\n                throw new Error(\"Could not find profile with profile name '\" + profileName + \"'.\");\n            }\n            mapping.profile = profile;\n            // merge mappings\n            this.createMapWithProfileMergeMappings(mapping, profileName);\n        };\n        AutoMapper.prototype.createMapWithProfileMergeMappings = function (mapping, profileName) {\n            var profileMappingKey = profileName + \"=>\" + mapping.sourceKey + profileName + \"=>\" + mapping.destinationKey;\n            var profileMapping = this._mappings[profileMappingKey];\n            if (!profileMapping) {\n                return;\n            }\n            // append forAllMemberMappings calls to the original array.\n            if (profileMapping.forAllMemberMappings.length > 0) {\n                (_a = mapping.forAllMemberMappings).push.apply(_a, profileMapping.forAllMemberMappings);\n            }\n            // overwrite original type converter function\n            if (profileMapping.typeConverterFunction) {\n                mapping.typeConverterFunction = profileMapping.typeConverterFunction;\n            }\n            // overwrite original type converter function\n            if (profileMapping.destinationTypeClass) {\n                mapping.destinationTypeClass = profileMapping.destinationTypeClass;\n            }\n            // walk through all the profile's property mappings\n            for (var _i = 0, _b = profileMapping.properties; _i < _b.length; _i++) {\n                var property = _b[_i];\n                this.mergeProperty(mapping, mapping.properties, property);\n            }\n            var _a;\n        };\n        AutoMapper.prototype.mergeProperty = function (mapping, properties, property) {\n            var overwritten = false;\n            for (var index = 0; index < mapping.properties.length; index++) {\n                var existing = mapping.properties[index];\n                if (existing.name === property.name) {\n                    // in which case, we overwrite that one with the profile's property mapping.\n                    // okay, maybe a bit rude, but real merging is pretty complex and you should\n                    // probably not want to combine normal and profile createMap.forMember calls.\n                    mapping.properties[index] = property;\n                    overwritten = true;\n                }\n            }\n            if (overwritten === false) {\n                mapping.properties.push(property);\n            }\n        };\n        AutoMapper.prototype.mapInternal = function (mapping, sourceObject) {\n            if (mapping.async) {\n                throw new Error('Impossible to use asynchronous mapping using automapper.map(); use automapper.mapAsync() instead.');\n            }\n            if (_super.prototype.isArray.call(this, sourceObject)) {\n                return this.mapArray(mapping, sourceObject);\n            }\n            return mapping.mapItemFunction(mapping, sourceObject, _super.prototype.createDestinationObject.call(this, mapping.destinationTypeClass));\n        };\n        AutoMapper.prototype.mapArray = function (mapping, sourceArray) {\n            var destinationArray = _super.prototype.handleArray.call(this, mapping, sourceArray, function (sourceObject, destinationObject) {\n                mapping.mapItemFunction(mapping, sourceObject, destinationObject);\n            });\n            return destinationArray;\n        };\n        AutoMapper.prototype.mapItem = function (mapping, sourceObject, destinationObject) {\n            var _this = this;\n            destinationObject = _super.prototype.handleItem.call(this, mapping, sourceObject, destinationObject, function (propertyName) {\n                _this.mapProperty(mapping, sourceObject, destinationObject, propertyName);\n            });\n            return destinationObject;\n        };\n        AutoMapper.prototype.mapItemUsingTypeConverter = function (mapping, sourceObject, destinationObject, arrayIndex) {\n            var resolutionContext = {\n                sourceValue: sourceObject,\n                destinationValue: destinationObject\n            };\n            return mapping.typeConverterFunction(resolutionContext);\n        };\n        AutoMapper.prototype.mapProperty = function (mapping, sourceObject, destinationObject, sourceProperty) {\n            var _this = this;\n            _super.prototype.handleProperty.call(this, mapping, sourceObject, sourceProperty, destinationObject, function (destinations, valuesAndFunctions, opts) {\n                var destinationPropertyValue = _this.handlePropertyMappings(valuesAndFunctions, opts);\n                for (var _i = 0, destinations_1 = destinations; _i < destinations_1.length; _i++) {\n                    var destination = destinations_1[_i];\n                    _super.prototype.setPropertyValue.call(_this, mapping, destinationObject, destination, destinationPropertyValue);\n                }\n            });\n        };\n        AutoMapper.prototype.handlePropertyMappings = function (valuesAndFunctions, opts) {\n            if (!valuesAndFunctions || valuesAndFunctions.length === 0) {\n                return opts.intermediatePropertyValue;\n            }\n            var valueOrFunction = valuesAndFunctions[0];\n            if (typeof valueOrFunction === 'function') {\n                var result = valueOrFunction(opts);\n                if (typeof result !== 'undefined') {\n                    opts.intermediatePropertyValue = result;\n                }\n                // recursively walk values/functions\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\n            }\n            else {\n                // valueOrFunction is a value\n                opts.intermediatePropertyValue = valueOrFunction;\n                // recursively walk values/functions\n                return this.handlePropertyMappings(valuesAndFunctions.slice(1), opts);\n            }\n        };\n        AutoMapper.prototype.createMappingObjectForGivenKeys = function (srcKeyOrType, dstKeyOrType) {\n            var _this = this;\n            var mapping = {\n                sourceKey: _super.prototype.getKey.call(this, srcKeyOrType),\n                destinationKey: _super.prototype.getKey.call(this, dstKeyOrType),\n                forAllMemberMappings: new Array(),\n                properties: [],\n                propertiesNew: [],\n                typeConverterFunction: undefined,\n                mapItemFunction: function (m, srcObj, dstObj) { return _this.mapItem(m, srcObj, dstObj); },\n                sourceTypeClass: (typeof srcKeyOrType === 'string' ? undefined : srcKeyOrType),\n                destinationTypeClass: (typeof dstKeyOrType === 'string' ? undefined : dstKeyOrType),\n                profile: undefined,\n                async: false\n            };\n            this._mappings[mapping.sourceKey + mapping.destinationKey] = mapping;\n            return mapping;\n        };\n        AutoMapper.prototype.createMapGetFluentApiFunctions = function (mapping) {\n            var _this = this;\n            // create a fluent interface / method chaining (e.g. automapper.createMap().forMember().forMember() ...)\n            var fluentFunc = {\n                forMember: function (prop, valFunc) {\n                    _this.createMapForMemberNewVersion({\n                        mapping: mapping,\n                        propertyName: prop,\n                        transformation: valFunc,\n                        sourceMapping: false,\n                        fluentFunctions: fluentFunc\n                    });\n                    return _this.createMapForMember({\n                        mapping: mapping,\n                        fluentFunctions: fluentFunc,\n                        destinationProperty: prop,\n                        conversionValueOrFunction: valFunc,\n                        sourceMapping: false\n                    });\n                },\n                forSourceMember: function (prop, cfgFunc) {\n                    _this.createMapForMemberNewVersion({\n                        mapping: mapping,\n                        propertyName: prop,\n                        transformation: cfgFunc,\n                        sourceMapping: true,\n                        fluentFunctions: fluentFunc\n                    });\n                    return _this.createMapForSourceMember(mapping, fluentFunc, prop, cfgFunc);\n                },\n                forAllMembers: function (func) {\n                    return _this.createMapForAllMembers(mapping, fluentFunc, func);\n                },\n                ignoreAllNonExisting: function () { return _this.createMapIgnoreAllNonExisting(mapping, fluentFunc); },\n                convertToType: function (type) { return _this.createMapConvertToType(mapping, fluentFunc, type); },\n                convertUsing: function (tcClassOrFunc) {\n                    return _this.createMapConvertUsing(mapping, tcClassOrFunc);\n                },\n                withProfile: function (profile) { return _this.createMapWithProfile(mapping, profile); }\n            };\n            return fluentFunc;\n        };\n        AutoMapper.prototype.createMapForMemberNewVersion = function (parameters) {\n            var mapping = parameters.mapping, propertyName = parameters.propertyName, transformation = parameters.transformation, sourceMapping = parameters.sourceMapping, fluentFunctions = parameters.fluentFunctions;\n            // extract source/destination property names\n            var metadata = AutoMapperJs.AutoMapperHelper.getMappingMetadataFromTransformationFunction(propertyName, transformation, sourceMapping);\n            this.validateForMemberParameters(metadata);\n            var source = metadata.source, destination = metadata.destination;\n            // create property (regardless of current existance)\n            var property = this.createSourceProperty(metadata, null);\n            // merge with existing property or add property\n            if (!this.mergeSourceProperty(property, mapping.propertiesNew, sourceMapping)) {\n                mapping.propertiesNew.push(property);\n            }\n            return fluentFunctions;\n        };\n        AutoMapper.prototype.validateForMemberParameters = function (metadata) {\n            if (!metadata.sourceMapping) {\n                return;\n            }\n            // validate forSourceMember parameters\n            if (metadata.transformation.transformationType === AutoMapperJs.DestinationTransformationType.Constant) {\n                throw new Error('Configuration of forSourceMember has to be a function with one (sync) or two (async) options parameters.');\n            }\n        };\n        AutoMapper.prototype.createSourceProperty = function (metadata, parent) {\n            var level = !parent ? 0 : parent.level + 1;\n            var sourceNameParts = metadata.source.split('.');\n            if (level >= sourceNameParts.length) {\n                return null;\n            }\n            var source = {\n                name: sourceNameParts[level],\n                sourcePropertyName: metadata.source,\n                destinationPropertyName: metadata.destination,\n                parent: parent,\n                level: level,\n                children: [],\n                destination: null\n            };\n            if ((level + 1) < sourceNameParts.length) {\n                // recursively add child source properties ...\n                var child = this.createSourceProperty(metadata, source);\n                if (child) {\n                    source.children.push(child);\n                }\n                source.destination = null;\n            }\n            else {\n                // ... or (!) add destination\n                source.destination = this.createDestinationProperty(metadata, null);\n            }\n            return source;\n        };\n        AutoMapper.prototype.createDestinationProperty = function (metadata, parent) {\n            var level = !parent ? 0 : parent.level + 1;\n            var destinationNameParts = metadata.destination.split('.');\n            if (level >= destinationNameParts.length) {\n                return null;\n            }\n            var destination = {\n                name: destinationNameParts[level],\n                sourcePropertyName: metadata.source,\n                destinationPropertyName: metadata.destination,\n                parent: parent,\n                level: level,\n                child: null,\n                transformations: [],\n                ignore: false,\n                sourceMapping: false\n            };\n            if ((level + 1) < destinationNameParts.length) {\n                // recursively add child destination properties\n                destination.child = this.createDestinationProperty(metadata, destination);\n            }\n            else {\n                // add/merge properties\n                destination.sourceMapping = metadata.sourceMapping;\n                destination.ignore = metadata.ignore;\n                destination.transformations.push(metadata.transformation);\n            }\n            return destination;\n        };\n        AutoMapper.prototype.mergeSourceProperty = function (property, existingProperties, sourceMapping) {\n            // find source property\n            var existing = sourceMapping\n                ? this.findProperty(property.name, existingProperties)\n                : this.matchSourcePropertyByDestination(property, existingProperties);\n            if (!existing) {\n                return false;\n            }\n            if (property.destination) {\n                if (existing.children.length > 0) {\n                    var existingDestination = this.getDestinationProperty(existing.destinationPropertyName, existing);\n                    // existing is (further) nested => rebase and/or merge\n                    if (this.handleMapFromProperties(property, existing)) {\n                        // merge and rebase existing destination to current source level\n                        if (!this.mergeDestinationProperty(property.destination, existingDestination)) {\n                            return false;\n                        }\n                        existing.destination = existingDestination;\n                        existing.children = [];\n                        return true;\n                    }\n                    // merge property.destination with existing mapFrom() destination (don't care about nesting depth here)\n                    return this.mergeDestinationProperty(property.destination, existingDestination);\n                }\n                // both are at same level => simple merge.\n                if (!this.mergeDestinationProperty(property.destination, existing.destination)) {\n                    return false;\n                }\n                this.handleMapFromProperties(property, existing);\n                return true;\n            }\n            if (property.children.length > 0) {\n                // new source is (further) nested.\n                if (existing.children.length > 0) {\n                    // both have further nesting, delegate merging child(ren) by recursively calling this function.\n                    for (var _i = 0, _a = property.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        if (!this.mergeSourceProperty(child, existing.children, sourceMapping)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                // existing is not (further) nested. this is always a mapFrom() situation. \n                if (property.sourcePropertyName !== existing.sourcePropertyName) {\n                    var newDestination = this.getDestinationProperty(existing.destinationPropertyName, property);\n                    if (property.destinationPropertyName !== property.sourcePropertyName) {\n                        // this is a mapFrom() registration. In that case:\n                        // 1) merge destinations, 2) add source child and 3) move destination to (youngest) child\n                        // NOTE special mergeDestinationProperty call => we use the new destination as 'target',\n                        //      because that will save us trouble overwriting ;)...\n                        if (!this.mergeDestinationProperty(existing.destination, newDestination)) {\n                            return false;\n                        }\n                        existing.children = property.children;\n                        existing.name = property.name;\n                        existing.sourcePropertyName = property.sourcePropertyName;\n                        // TODO Should never be necessary (test): existing.destinationPropertyName = property.destinationPropertyName;\n                        return true;\n                    }\n                    // ... nope, it is a destination which has previously been registered using mapFrom. just merge\n                    return this.mergeDestinationProperty(newDestination, existing.destination);\n                }\n            }\n            throw new Error('TODO TEST AND REMOVE => Source property should have destination or child(ren)');\n        };\n        /**\n         * handle property naming when the current property to merge is a mapFrom property\n         */\n        AutoMapper.prototype.handleMapFromProperties = function (property, existingProperty) {\n            if (property.destinationPropertyName === property.sourcePropertyName ||\n                property.sourcePropertyName === existingProperty.sourcePropertyName) {\n                return false;\n            }\n            // only overwrite name when a mapFrom situation applies\n            existingProperty.name = property.name;\n            existingProperty.sourcePropertyName = property.sourcePropertyName;\n            // TODO Should never be necessary (test) => existingProperty.destinationPropertyName = property.destinationPropertyName;\n            return true;\n        };\n        AutoMapper.prototype.getDestinationProperty = function (destinationPropertyName, existingSource) {\n            if (existingSource.destination) {\n                return existingSource.destination;\n            }\n            if (existingSource.children) {\n                for (var _i = 0, _a = existingSource.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var destination = this.getDestinationProperty(destinationPropertyName, child);\n                    if (destination) {\n                        return destination;\n                    }\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.mergeDestinationProperty = function (destination, existingDestination) {\n            if (destination.child) {\n                if (existingDestination.child) {\n                    // both have further nesting, delegate merging children by recursively calling this function.\n                    if (!this.mergeDestinationProperty(destination.child, existingDestination.child)) {\n                        return false;\n                    }\n                    this.handleMapFromProperties(destination, existingDestination);\n                    return true;\n                }\n                // the current destination is not (further) nested. a destination property registration has one of both: \n                // a) children or b) transformations. returning false will cause creating a duplicate source property entry instead.\n                return false;\n            }\n            if (existingDestination.sourceMapping !== destination.sourceMapping &&\n                existingDestination.sourcePropertyName !== destination.sourcePropertyName) {\n                // unable to perform mapFrom() on a property which is being registered using forSourceMember.\n                return false; // TODO: Unpredictable? Idea: throw new Error('Unable to perform mapFrom() on a property which is being registered using forSourceMember.');\n            }\n            // merge destination properties\n            existingDestination.sourceMapping = destination.sourceMapping;\n            existingDestination.ignore = destination.ignore;\n            for (var _i = 0, _a = destination.transformations; _i < _a.length; _i++) {\n                var transformation = _a[_i];\n                existingDestination.transformations.push(transformation);\n            }\n            this.handleMapFromProperties(destination, existingDestination);\n            return true;\n        };\n        AutoMapper.prototype.matchSourcePropertyByDestination = function (source, properties) {\n            if (!properties) {\n                return null;\n            }\n            for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {\n                var property = properties_3[_i];\n                if (property.destinationPropertyName === source.destinationPropertyName) {\n                    return property;\n                }\n            }\n            return null;\n        };\n        AutoMapper.prototype.findProperty = function (name, properties) {\n            if (!properties) {\n                return null;\n            }\n            for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {\n                var property = properties_4[_i];\n                if (property.name === name) {\n                    return property;\n                }\n            }\n            return null;\n        };\n        AutoMapper._instance = new AutoMapper();\n        return AutoMapper;\n    }(AutoMapperJs.AutoMapperBase));\n    AutoMapperJs.AutoMapper = AutoMapper;\n})(AutoMapperJs || (AutoMapperJs = {}));\n// Add AutoMapper to the application's global scope. Of course, you could still use Core.AutoMapper.getInstance() as well.\nvar automapper = (function (app) {\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\n    return app.automapper;\n})(this);\n\n//# sourceMappingURL=AutoMapper.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\n/// <reference path=\"../../src/ts/AutoMapper.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * Converts source type to destination type instead of normal member mapping\n     */\n    var Profile = (function () {\n        function Profile() {\n        }\n        /**\n         * Implement this method in a derived class and call the CreateMap method to associate that map with this profile.\n         * Avoid calling the AutoMapper class / automapper instance from this method.\n         */\n        Profile.prototype.configure = function () {\n            // do nothing\n        };\n        /**\n         * Create a mapping profile.\n         * @param {string} sourceKey The map source key.\n         * @param {string} destinationKey The map destination key.\n         * @returns {Core.ICreateMapFluentFunctions}\n         */\n        Profile.prototype.createMap = function (sourceKey, destinationKey) {\n            var argsCopy = Array.prototype.slice.apply(arguments);\n            for (var index = 0, length = argsCopy.length; index < length; index++) {\n                if (!argsCopy[index]) {\n                    continue;\n                }\n                // prefix sourceKey and destinationKey with 'profileName=>'\n                argsCopy[index] = this.profileName + \"=>\" + argsCopy[index];\n            }\n            // pass through using arguments to keep createMap's currying support fully functional.\n            return automapper.createMap.apply(automapper, argsCopy);\n        };\n        return Profile;\n    }());\n    AutoMapperJs.Profile = Profile;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=Profile.js.map\n","/// <reference path=\"../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    /**\n     * Converts source type to destination type instead of normal member mapping\n     */\n    var TypeConverter = (function () {\n        function TypeConverter() {\n        }\n        /**\n         * Performs conversion from source to destination type.\n         * @param {IResolutionContext} resolutionContext Resolution context.\n         * @returns {any} Destination object.\n         */\n        TypeConverter.prototype.convert = function (resolutionContext) {\n            // NOTE BL Unfortunately, TypeScript/JavaScript do not support abstract base classes.\n            //         This is just one way around, please convince me about a better solution.\n            throw new Error('The TypeConverter.convert method is abstract. Use a TypeConverter extension class instead.');\n        };\n        return TypeConverter;\n    }());\n    AutoMapperJs.TypeConverter = TypeConverter;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=TypeConverter.js.map\n","/// <reference path=\"../../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var CamelCaseNamingConvention = (function () {\n        function CamelCaseNamingConvention() {\n            this.splittingExpression = /(^[a-z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n            this.separatorCharacter = '';\n        }\n        CamelCaseNamingConvention.prototype.transformPropertyName = function (sourcePropertyNameParts) {\n            // Transform the splitted parts.\n            var result = '';\n            for (var index = 0, length = sourcePropertyNameParts.length; index < length; index++) {\n                if (index === 0) {\n                    result += sourcePropertyNameParts[index].charAt(0).toLowerCase() +\n                        sourcePropertyNameParts[index].substr(1);\n                }\n                else {\n                    result += sourcePropertyNameParts[index].charAt(0).toUpperCase() +\n                        sourcePropertyNameParts[index].substr(1);\n                }\n            }\n            return result;\n        };\n        return CamelCaseNamingConvention;\n    }());\n    AutoMapperJs.CamelCaseNamingConvention = CamelCaseNamingConvention;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=CamelCaseNamingConvention.js.map\n","/// <reference path=\"../../../dist/automapper-interfaces.d.ts\" />\nvar AutoMapperJs;\n(function (AutoMapperJs) {\n    'use strict';\n    var PascalCaseNamingConvention = (function () {\n        function PascalCaseNamingConvention() {\n            this.splittingExpression = /(^[A-Z]+(?=$|[A-Z]{1}[a-z0-9]+)|[A-Z]?[a-z0-9]+)/;\n            this.separatorCharacter = '';\n        }\n        PascalCaseNamingConvention.prototype.transformPropertyName = function (sourcePropertyNameParts) {\n            // Transform the splitted parts.\n            var result = '';\n            for (var index = 0, length = sourcePropertyNameParts.length; index < length; index++) {\n                result += sourcePropertyNameParts[index].charAt(0).toUpperCase() +\n                    sourcePropertyNameParts[index].substr(1);\n            }\n            return result;\n        };\n        return PascalCaseNamingConvention;\n    }());\n    AutoMapperJs.PascalCaseNamingConvention = PascalCaseNamingConvention;\n})(AutoMapperJs || (AutoMapperJs = {}));\n\n//# sourceMappingURL=PascalCaseNamingConvention.js.map\n"]}